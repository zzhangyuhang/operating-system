# 进程和线程
## 进程
### 定义
* 进程:一个具有一定独立功能的程序在一个数据集合上的一次**动态执行过程**.

### 组成
* 程序代码
* 程序处理的数据
* 程序计数器中的指示的运行的指令
* 一组通用寄存器的当前值,堆,栈
* 一组系统资源(内存,外存,网络,cpu)

总之,包含了正在运行的一个程序的所有状态信息.

### 进程和程序的关系
#### 联系
* 程序是产生进程的基础
* 程序的每次运行都构成不同的进程,因为数据和使用的系统资源不同
* 进程是程序功能的体现.
* 通过多次执行,某一个程序对应多个进程
* 通过调用,某一个进程包括多个程序

#### 区别
* 程序是静态的,有序代码的集合
* 进程是动态,执行中可以是用户态/核心态 (状态在用户系统调用的时候转换)
* 进程是暂时的,是状态变化的过程,而程序是永久的.
* 进程包括程序,数据,进程控制块(进程状态信息),程序只包含代码.

### 进程的特点
* 动态性,可以动态创建,结束进程.(为并发提供了基础,可以在虚拟内存中随时创建或结束,实现进程间的切换执行)
* 并发性(在一段时间内有多个程序正在执行.注意,跟并行不一样.并行是一个时间点上有多个程序执行,但需要具有多个CPU)
* 独立性,不同进程的工作相互不受影响.(通过页表机制控制每个程序所能访问的内存范围,不能越界访问别的进程的内存)
* 制约性,因访问共享数据/资源或进程间同步产生制约,需要同步互斥.

### 进程控制结构
#### 进程控制块(PCB)
* 描述进程的数据结构:进程控制块(PCB,process control block)
* OS给每个进程都维护了一个PCB,保存与之相关的所有状态信息.
* 进程控制块是操作系统管理控制进程运行所用的信息集合.
* 操作系统用PCB来描述进程的基本情况以及运行变化的过程.
* PCB是进程存在的唯一标志.
* 进程状态描述
	* 进程的创建:为该进程生辰给一个PCB
	* 进程的终止:回收它的PCB
	* 进程的组织和管理:通过对PCB的组织管理来实现

#### PCB组成
* 进程标识信息.
	* 本进程的标识
	* 本进程的生产者(父进程)标识
	* 用户标识
* 处理机状态信息保护区,保护进程的运行现场信息.
	* 用户可见寄存器,用户程序可以使用的数据,地址等寄存器
	* 控制和状态寄存器,如程序计数器(PC),程序状态字(PSW)
	* 栈指针,过程调用/系统调用/中断处理和返回所用到的指针.
* 进程控制信息
	* 调度和状态信息,用于操作系统调度进程并占用处理机使用.运行状态?等待?进程当前的执行现状.
	* 进程间的通信,为支持进程间的通信相关的各种标识,信号等.这些信息存在接受方的进程控制块里.
	* 存储管理信息,包含有指向本金诚映像空间的数据结构.内存信息,占了多少?要不要回收?
	* 进程的所用资源,打开使用的系统资源,如文件.
	* 有关数据结构连接信息,父进程,子进程构成一个链,进行可以连接到一个进程队列,或者连接到其他进程的PCB.

#### PCB组织方式
* 链表:由于进程PCB需要频繁的插入和删除,所以采用插入删除效率较高的链表,而不是数组.同一状态的PCB为一条链表,多个状态对应不同个链表.(状态指进程状态)

![链表组织PCB](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.链表组织PCB.png)

* 索引表(数组):同一状态的归入一个index(由index指向PCB),多个状态对应不同的index表.适用于进程状态变更不频繁的操作系统,不利于插入删除,适用于拱顶数据的进程.,

![索引组织PCB](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.索引组织PCB.png)

### 进程状态
* 进程的状态有:创建,就绪,运行,等待,唤醒,结束.

#### 状态描述
* 进程创建
	* 系统初始化,创建init进程,init进程负责创建其他进程
	* 用户请求创建一个新进程
	* 正在运行的进程执行了创建进程的系统调用
* 进程就绪
	* 除了获取CPU之外的其他所有资源,一旦拥有CPU就能运行
* 进程运行
	* 内核选择一个就绪的进程,让他占用CPU并执行.(通过调度算法来选择进程)
* 进程(阻塞)等待 - 进程只能自己触发阻塞和等待.只有自己才知道何时需要等待
	* 请求等待系统服务,无法马上完成
	* 启动某种操作(和其他进程协调工作),无法马上完成
	* 需要的数据没有到达
* 进程唤醒 - 进程只能被别的进程或操作系统唤醒,因为自身没占用CPU
	* 被阻塞进程需要的资源被满足
	* 被阻塞进程等待的时间到达
	* 将进程的PCB插入到就绪队列
* 进程结束
	* 正常退出(自愿)
	* 错度退出(自愿)
	* 致命错误(强制)
	* 被其他进程杀死(强制)

#### 状态转化

![进程状态转化图](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.进程状态转化图.png)

* 创建态(new):一个进程正在被创建,还没被转到就绪状态之前的状态.
* 结束态(exit):一个进程正在从系统中消失的状态,PCB还在.

* running -> ready:该进程拥有时间片到了,就切换到另一个进程,这个就变成就绪状态.
* new -> ready:很快,只是生成PCB.

### 进程挂起(suspend)
#### 概念
* 进程挂起不同于阻塞状态.挂起时没有占用内存空间,而是把进程放到了磁盘的虚拟内存中.从一个进程从内存到外存中.可以合理充分的利用系统资源.

#### 状态描述
* 阻塞挂起:进程在外存等待事件(blocked suspend)
* 就绪挂起:进程在外存,进入内存就能直接执行(ready suspend)

#### 状态转换
* 挂起:把一个进程从内存转到外存.
	* 阻塞到阻塞挂起:没有进程处于就绪状态或就绪进程要求更多内存资源时,会进行这种转换,以提交新进程或运行就绪进程.
	* 就绪到就绪挂起:当有高优先级阻塞(系统认为很多就绪的)进程和低优先就绪进程时,系统会选择挂起低优先级就绪进程.
	* 运行到就绪挂起:对抢先式分时系统,当有高优先级阻塞挂起进程因时间出局而进入就绪挂起时,系统可能会把运行进程转到就绪挂起状态.
* 在外存时的状态转换:
	* 阻塞挂起到就绪挂起:当有阻塞挂起进程因相关事件出现时,系统会把阻塞挂起进程转换为就绪挂起进程.状态虽然转换,但是还在磁盘上.
* 解挂/激活(activate):外存到内存,需要运行该进程.
	* 就绪挂起到就绪:没有就绪进程或挂起就绪进程优先级高于就绪进程时,会进行这种转换.
	* 阻塞挂起到阻塞:当一个进程释放足有内存时,系统会把一个优先级高的阻塞挂起进程转换为堵塞进程.

### 状态队列

OS怎么通过对PCB和定义的进程状态进行管理?

* 由操作系统来维护一组队列,用来表示系统当中所有进程的当前状态.
* 不同的状态分别用不同的队列来表示(根据状态区分的队列)
* 每个进程的PCB都根据状态加入到响应的队列当中,当一个进程的状态发生变化时,它的PCB从一个状态队列中脱离出来,加入到另一个队列.

![状态队列表示法](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.状态队列表示法.png) 

如图所示,根据不同状态和不同的优先级会有不同的PCB管理队列,然后处理机(CPU)选取响应的进程,并选取其PCB进行执行,然后加入到响应变化状态的队列中.
