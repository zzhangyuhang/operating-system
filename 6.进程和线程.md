# 进程和线程
## 进程
### 定义
* 进程:一个具有一定独立功能的程序在一个数据集合上的一次**动态执行过程**.

### 组成
* 程序代码
* 程序处理的数据
* 程序计数器中的指示的运行的指令
* 一组通用寄存器的当前值,堆,栈
* 一组系统资源(内存,外存,网络,cpu)

总之,包含了正在运行的一个程序的所有状态信息.

### 进程和程序的关系
#### 联系
* 程序是产生进程的基础
* 程序的每次运行都构成不同的进程,因为数据和使用的系统资源不同
* 进程是程序功能的体现.
* 通过多次执行,某一个程序对应多个进程
* 通过调用,某一个进程包括多个程序

#### 区别
* 程序是静态的,有序代码的集合
* 进程是动态,执行中可以是用户态/核心态 (状态在用户系统调用的时候转换)
* 进程是暂时的,是状态变化的过程,而程序是永久的.
* 进程包括程序,数据,进程控制块(进程状态信息),程序只包含代码.

### 进程的特点
* 动态性,可以动态创建,结束进程.(为并发提供了基础,可以在虚拟内存中随时创建或结束,实现进程间的切换执行)
* 并发性(在一段时间内有多个程序正在执行.注意,跟并行不一样.并行是一个时间点上有多个程序执行,但需要具有多个CPU)
* 独立性,不同进程的工作相互不受影响.(通过页表机制控制每个程序所能访问的内存范围,不能越界访问别的进程的内存)
* 制约性,因访问共享数据/资源或进程间同步产生制约,需要同步互斥.

### 进程控制结构
#### 进程控制块(PCB)
* 描述进程的数据结构:进程控制块(PCB,process control block)
* OS给每个进程都维护了一个PCB,保存与之相关的所有状态信息.
* 进程控制块是操作系统管理控制进程运行所用的信息集合.
* 操作系统用PCB来描述进程的基本情况以及运行变化的过程.
* PCB是进程存在的唯一标志.
* 进程状态描述
	* 进程的创建:为该进程生辰给一个PCB
	* 进程的终止:回收它的PCB
	* 进程的组织和管理:通过对PCB的组织管理来实现

#### PCB组成
* 进程标识信息.
	* 本进程的标识
	* 本进程的生产者(父进程)标识
	* 用户标识
* 处理机状态信息保护区,保护进程的运行现场信息.
	* 用户可见寄存器,用户程序可以使用的数据,地址等寄存器
	* 控制和状态寄存器,如程序计数器(PC),程序状态字(PSW)
	* 栈指针,过程调用/系统调用/中断处理和返回所用到的指针.
* 进程控制信息
	* 调度和状态信息,用于操作系统调度进程并占用处理机使用.运行状态?等待?进程当前的执行现状.
	* 进程间的通信,为支持进程间的通信相关的各种标识,信号等.这些信息存在接受方的进程控制块里.
	* 存储管理信息,包含有指向本金诚映像空间的数据结构.内存信息,占了多少?要不要回收?
	* 进程的所用资源,打开使用的系统资源,如文件.
	* 有关数据结构连接信息,父进程,子进程构成一个链,进行可以连接到一个进程队列,或者连接到其他进程的PCB.

#### PCB组织方式
* 链表:由于进程PCB需要频繁的插入和删除,所以采用插入删除效率较高的链表,而不是数组.同一状态的PCB为一条链表,多个状态对应不同个链表.(状态指进程状态)

![链表组织PCB](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.链表组织PCB.png)

* 索引表(数组):同一状态的归入一个index(由index指向PCB),多个状态对应不同的index表.适用于进程状态变更不频繁的操作系统,不利于插入删除,适用于拱顶数据的进程.,

![索引组织PCB](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.索引组织PCB.png)

### 进程状态
* 进程的状态有:创建,就绪,运行,等待,唤醒,结束.

#### 状态描述
* 进程创建
	* 系统初始化,创建init进程,init进程负责创建其他进程
	* 用户请求创建一个新进程
	* 正在运行的进程执行了创建进程的系统调用
* 进程就绪
	* 除了获取CPU之外的其他所有资源,一旦拥有CPU就能运行
* 进程运行
	* 内核选择一个就绪的进程,让他占用CPU并执行.(通过调度算法来选择进程)
* 进程(阻塞)等待 - 进程只能自己触发阻塞和等待.只有自己才知道何时需要等待
	* 请求等待系统服务,无法马上完成
	* 启动某种操作(和其他进程协调工作),无法马上完成
	* 需要的数据没有到达
* 进程唤醒 - 进程只能被别的进程或操作系统唤醒,因为自身没占用CPU
	* 被阻塞进程需要的资源被满足
	* 被阻塞进程等待的时间到达
	* 将进程的PCB插入到就绪队列
* 进程结束
	* 正常退出(自愿)
	* 错度退出(自愿)
	* 致命错误(强制)
	* 被其他进程杀死(强制)

#### 状态转化

![进程状态转化图](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.进程状态转化图.png)

* 创建态(new):一个进程正在被创建,还没被转到就绪状态之前的状态.
* 结束态(exit):一个进程正在从系统中消失的状态,PCB还在.

* running -> ready:该进程拥有时间片到了,就切换到另一个进程,这个就变成就绪状态.
* new -> ready:很快,只是生成PCB.

### 进程挂起(suspend)
#### 概念
* 进程挂起不同于阻塞状态.挂起时没有占用内存空间,而是把进程放到了磁盘的虚拟内存中.从一个进程从内存到外存中.可以合理充分的利用系统资源.

#### 状态描述
* 阻塞挂起:进程在外存等待事件(blocked suspend)
* 就绪挂起:进程在外存,进入内存就能直接执行(ready suspend)

#### 状态转换
* 挂起:把一个进程从内存转到外存.
	* 阻塞到阻塞挂起:没有进程处于就绪状态或就绪进程要求更多内存资源时,会进行这种转换,以提交新进程或运行就绪进程.
	* 就绪到就绪挂起:当有高优先级阻塞(系统认为很多就绪的)进程和低优先就绪进程时,系统会选择挂起低优先级就绪进程.
	* 运行到就绪挂起:对抢先式分时系统,当有高优先级阻塞挂起进程因时间出局而进入就绪挂起时,系统可能会把运行进程转到就绪挂起状态.
* 在外存时的状态转换:
	* 阻塞挂起到就绪挂起:当有阻塞挂起进程因相关事件出现时,系统会把阻塞挂起进程转换为就绪挂起进程.状态虽然转换,但是还在磁盘上.
* 解挂/激活(activate):外存到内存,需要运行该进程.
	* 就绪挂起到就绪:没有就绪进程或挂起就绪进程优先级高于就绪进程时,会进行这种转换.
	* 阻塞挂起到阻塞:当一个进程释放足有内存时,系统会把一个优先级高的阻塞挂起进程转换为堵塞进程.

### 状态队列

OS怎么通过对PCB和定义的进程状态进行管理?

* 由操作系统来维护一组队列,用来表示系统当中所有进程的当前状态.
* 不同的状态分别用不同的队列来表示(根据状态区分的队列)
* 每个进程的PCB都根据状态加入到响应的队列当中,当一个进程的状态发生变化时,它的PCB从一个状态队列中脱离出来,加入到另一个队列.

![状态队列表示法](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.状态队列表示法.png) 

如图所示,根据不同状态和不同的优先级会有不同的PCB管理队列,然后处理机(CPU)选取响应的进程,并选取其PCB进行执行,然后加入到响应变化状态的队列中.

## 线程
### 进程存在的问题
* 进程在操作系统中的管理是相互独立的,而且是有独立内存地址,怎么实现共享数据?
* 维护进程的系统开销大,因为时常涉及缺页中断.
* 线程创建时,分配资源,建立PCB;撤销线程时,回收资源,撤销PCB;线程切换时,保存当前的进程状态.
* 进程中的程序只能线性执行.

### 什么是线程
* 线程是进程中更小的能独立运行的基本单位.
* 线程存在于进程中,可以并发的执行提高工作效率.
* 线程可以共享进程中的地址空间,可以完成共享数据.
* 线程 = 进程 - 共享资源

### 重新理解进程
* 进程由两部分组成
	* 从资源管理角度,把一组相关的资源组合起来,包括地址空间(代码段,数据段),打开的文件等的资源平台(环境)等.
	* 从运行的角度.线程即代码在这个资源平台上的一条执行流程.
	* 可以理解为 进程 = 资源 + 执行.
* 把进程的执行单元单独分离开,用线程来完成.进程继续管理资源,一个进程所拥有的线程共用进程的资源平台.

![进程和线程的关系](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.进程和线程的关系.png)

如图,每个线程是代码的一部分,每个线程都有自己的TCB(thread control block)-线程控制块,包括PC程序计数器,SP堆栈,State状态和寄存器.有不同的控制流,需要不同的寄存器来表示控制流的执行状态,每个线程独立拥有自己这些信息,但共享一个资源.


![共享寄存器和栈的线程结构](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.共享寄存器和栈的线程结构.png)

如图,最上边是共享的资源:代码,数据和文件.拥有共享寄存器和栈的内部结构,每个时刻只能表示一个线程的控制流.

![非共享寄存器和栈的线程结构](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.非共享寄存器和栈的线程结构.png)

如果采用非共享结构,进程内有多个控制流且执行流程不一样

可以理解为每个线程都有自己的一个控制流,一个进程中可以同时存在多个线程,各个线程并发执行,共享地址空间和文件等资源.如果一个线程写错了,将破坏数据影响该进程内的所有线程.

### 进程和线程的比较
* 进程是资源(内存,打开的文件,访问的网络)分配单元,线程是CPU调度单位.
* 进程拥有一个完整资源平台,而线程只独享必不可少的资源如寄存器和栈.
* 线程同样具有就绪,阻塞和执行三种基本状态和转换状态.
* 线程是进程的一部分,但线程能减少并发执行的时空开销.
	* 线程的创建时间和终止时间以及切换时间都更短.因为进程要创建一些对内存和打开文件的管理信息,而线程可以直接用所属的进程的信息,因为同一进程的线程有有同一个地址空间,同一个页表,线程切换并不用切换这些资源,所有信息可以重用.而进程间的地址空间是独立的,切换的时候要切换页表,页面cache,TLB等,开销十分大.
	* 线程的数据传递不需要通过内核,直接通过内存地址同一个进程内的线程就能访问到.而进程共享数据的消息传递一定要通过内核,数据需要复制,而且会产生上下文切换,效率低.

### 线程的实现
* 用户线程,在用户空间实现,内核看不到,由应用程序的用户线程库来管理.POSIX
* 内核线程,在内核中实现,由内核直接管理.WINDOWS
* 轻量级进程,内核中实现,支持用户数据.LINUX

#### 用户线程(UT)

* 在用户控件实现的线程机制.在一个纯粹的用户级线程软件中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。

![用户线程](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.用户线程.png)

如图是用户线程结构,线程的TCB(线程控制块)在用户控件,内核看不到,所以线程并不能对其进行管理.而是用户控件有一组用户级的线程库函数来完成线程的管理,包括创建,终止,同步和调度等.

##### 优缺点
* 优点
	* 线程切换不需要内核态特权，进程并不需要为了线程管理而切换到内核态
	* 可以为应用程序量身定做调度算法而不扰乱底层的操作系统调度程序
	* 用户级线程可以在任何操作系统中运行，不需要对底层内核进行修改以支持用户级线程

* 缺点
	* 许多系统调用都会引起阻塞，当用户级线程执行一个系统调用时，不仅这个线程会被阻塞，进程中的所有线程都会被阻塞
	* 一个线程开始运行后,除非主动交出CPU使用权,否则所在进程中的其他线程都无法运行.
	* 没有内核参与无法实现多个CPU的并行执行.

#### 内核线程(KLT)
* 有关线程管理的所有工作都是由内核完成的，应用程序部分没有进行线程管理的代码，只有一个到内核线程设施的应用程序编程接口（API）.
* 内核的调度单位不再是进程而是线程。进程主要完成资源的管理

![内核线程](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.内核线程.png)

如图,内核维护PCB和TCB，PCB维护了一系列的TCB，具体调度是TCB完成.

##### 优缺点
* 优点
	* 内核可以同时把同一个进程的多个线程调度到多个处理器中.
	* 如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程.不会有用户线程导致这阻塞现象.
* 缺点
	* 完成一次线程切换（或创建，终止）就要完成一次用户态到内核态的变化
	* 系统调用/调用内核函数，内核开销比用户线程大。

#### 用户线程和内核线程的关系
* 用户线程与内核线程间，可以是多对一，一对一，多对多的关系.

![用户线程与内核线程关系](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.用户线程和内核线程关系.png)

#### 轻量级进程(LWP)
* 内核支持的用户线程,一个进程由一个或多个轻量级进程,每个轻量级进程由一个单独的内核线程来支持.Linux线程的主要实现方式就是采用这种轻量级进程的方式实现的.

![轻量级线程](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.轻量级线程.png)

如图,轻量级线程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有轻量级线程。每一个进程有一个或多个轻量级进程，每个轻量级进程由一个内核线程支持。每个轻量级进程都是一个独立的线程调度单元.

##### 优缺点
* 优点
	* 每个轻量级进程都是由内核线程支持的,并不户想用户线程那样在系统调用中阻塞,也不会影响整个进程的运行.
	* 可以通过内核的管理完成并行执行,对多核处理器有更好的支持.
* 缺点
	* 因为有内核的管理,所以在系统调用和切换等操作的时候需要进行用户态到内核态的转换.开销大.
	* 每个轻量级进程都需要一个内核线程支持,消耗内核资源.系统不能支持大量的轻量级进程.

## 上下文切换
### 概念
* 所有进程共享CPU,CPU停止当前运行的进程(从运行态改变成为其他状态),并调度其他进程(其他状态转变成为运行态)的切换叫做上下文切换.

### 切换的目标
* 必须在切换之前存储切换进程的上下文.
* 必须能够在切换之后能恢复他们,且不能显示被暂停过.
* 必须快速(上下文切换很频繁).
* 切换开销越小越好.

### 上下文存储
* 寄存器记录程序运行的位置
* 栈指针记录调用关系和响应的局部变量位置
* 这些值都被保存在PCB中,CPU恢复的时候也只能从PCB中恢复.
* 进程存储 - 状态队列
	* PC为活跃进程准备了进程控制块PCB,OS将不同PCB放在不同的状态队列链表里便于选择.
		* 就绪队列
		* 等待I/O队列,分为每个设备的队列
		* 僵尸队列

## 进程控制
### 创建进程
* 父进程创建子进程 - fork()
* fork创建了一个新的地址空间,然后子进程的地址空间完全复制了父进程.
* 实现
	* 先给子进程分配内存,然后复制父进程的内存和CPU寄存器到子进程中.开销大.
* 缺点:99%调用fork()为了接下来调用exec()子进程,fork中的内存复制父进程并没用.
* 解决办法:	
	* 省略复制父进程到子进程的过程 - vfork().vfork() 是轻量级的 fork().父进程在创建子进程的时候不创建一样的内存映像
	* copy on write(COW)技术.通过OS的虚存管理，只复制了父进程meta元数据即页表，指向的是同一地址空间，对某个地址单元进行写操作时触发异常，父子各把要用的页复制成两份，使父进程和子进程拥有不同的地址。按需，光读不用复制，写才用.

### 加载进程
* 系统加载程序取代当前运行的进程 - exec()
* exec（）允许一个进程加载一个不同段程序并在MAIN执行

### 等待进程
* 父进程等待子进程运行结束 - wait()
* 一个子进程向父进程返回一个值，父进程必须接受这个值并处理。
* 为什么父进程要等待子进程?而不是直接结束?
	* 当前进程执行完毕退出后,要回收所有的资源.操作系统要根据PCB来执行回收.子进程的PCB只能被父进程看到,只有父进程能够根据子进程PCB完成资源回收.
	* 具体流程:Wait使父进程睡眠，当子进程调用exit时操作系统解锁父进程，将通过子进程exit传递得到的返回值作为wait调用的一个结果（连同子进程的pid一起）。父进程关闭所有打开的文件和连接，释放内存，释放大部分支持进程的OS结构，检查父进程是否存活。 

### 退出进程
* 进程执行完毕后退出 - exit().
* exit()只是退出该程序,并没有将程序使用资源释放.

#### 僵尸状态(zombie)
* 子进程调用了exit(),退出进程,但还没有调用wait()将控制权给父进程释放掉该子进程资源。将死，还没死。无法正常工作，只是等待被父进程回收。
* 最早的进程ROOT进程/主动进程/RIT进程会定期扫描PCB列表，找到僵尸状态的进程并清理，使OS中不会僵尸越积越多。

![进程控制下的状态图](https://github.com/zzhangyuhang/operating-system/blob/master/photo/6.进程控制下的状态图.png)

如图,在父进程fork()下产生子进程,子进程进入new的新建状态.当在父进程exec()子进程的时候,子进程进入Running状态,然后父进程调用wait()子进程,等待子进程运行结束.Running结束后子进程调用exit()退出当前子进程,但是子进程的资源没有被回收进入僵尸状态(Zombie),当子进程的exit()接触(通过返回值和子进程的PID触发)了父进程的wait(),父进程取得控制权释放掉子进程的资源,子进程退出.

