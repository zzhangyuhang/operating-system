# 临界区的互斥
## 概念
### 线程合作
* 独立的线程
	* 不和其他线程共享资源或者状态
	* 确定性 -> 输入状态决定结果
	* 可重现 -> 能够重现起始条件,I/O
	* 调度顺序不重要
* 合作线程
	* 在多个线程中共享状态
	* 不确定性
	* 不可重现
* 不确定性和不可重现意味着bug可能是间歇性发生的
* 进程/线程需要合作
	* 共享资源
	* 加速
		* I/O操作和计算可以重叠
		* 多处理器,将程序分成多个部分并行执行
	* 模块化
		* 将大程序分解成小程序
		* 易于扩展

### 多线程设计目标
* 无论多个线程的指令序列怎样交替执行,程序都必须正常工作.
	* 多线程程序具有不确定性和不可重现的特点
	* 调试难度很高
* 不确定性要求并行程序的正确性
	* 无论怎样执行程序的最终结果应该正确一致

### 原子操作(Atomic Operation)
* 原子操作是指一次不存在任何中断或者失败的执行
	* 该执行成功结束或者根本没有执行
	* 没有任何部分执行
* 实际上的操作往往不是原子的,i++不是原子的

### 临界区(Critical section)
* 临界区是指进程中的一段需要访问**共享资源**并且当另一个进程处于相应代码区域时便不会被执行的代码区域.
* 同一时间临界区内最多存在一个线程
* 如果一个线程想要进入临界区,那么它最终会成功
* 临界区等待
	* 有限等待:进入临界区的线程时间是有限的,自旋
	* 无限等待:如果一个进程等待进入临界区被挂起
* 进入临界区需要获取到该临界区的锁,如果获取不到锁需要等待.退出临界区的时候需要释放临界区的锁以便其他进程能够使用临界区的共享资源.

![临界区](https://github.com/zzhangyuhang/operating-system/blob/master/photo/8.临界区.png)

### 互斥(Mutual exelusion)
* 当一个进程处于临界区并访问共享资源时,没有其他进程会处于临界区并且访问任何相同的共享资源.

### 死锁(Dead lock)
* 两个或以上的进程,在相互等待完成特定任务,而最终没法将自身任务进行下去
* 例如,A拿到锁1,B拿到锁2.A想继续拿到锁2后在继续执行,B想继续拿到锁1后再继续执行,导致A和B谁都无法继续执行.

### 饥饿(Starvation)
* 一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行

## 临界区的实现
### 禁止硬件中断
* 没有中断,没有上下文切换,因此没有并发
	* 硬件将中断处理延迟到中断被启用之后
	* 大多数现在计算机体系结构都提供指令来完成
* 进入临界区,禁止中断
* 离开临界区,开启中断
* 一旦中断被禁用,线程就无法被停止
	* 整个系统都会为你停下来
	* 可能导致其他进程处于饥饿状态
* 要是临界区任意长,无法限制响应中断所需时间
* 小心使用
* 适用于短临界区的情况

### 基于软件的方式

![临界区软件实现进程结构](https://github.com/zzhangyuhang/operating-system/blob/master/photo/8.临界区软件实现进程结构.png)

#### 共享变量做临界区标志
* 用turn共享变量代表允许进入临界区的进程号

```
int turn = 0;//初始化,当为0的时候说明临界区没有进程,可进入.

对Thread Ti:
do{
	while(turn != i); //当当前进程号等于turn所指向的进程号才可以往下执行
	critical section //进入临界区完成执行
	turn = j;//执行完毕,修改turn为下一个允许访问临界区的进程号
	reminder section //提醒j进程
}while(1);

```

* Ti在退出临界区后做其他的事情去了，Tj想继续运行，但必须等待Ti处理临界区.
* 必须是一种交替循环.

#### 数据做临界区标志
* 用数组来保存所有进程,每个进程对应一个数组的单元.数组值为0,1,表示是否进入临界区.

```
flag[i] = 1;//如果一个进程想要进入临界区,设置其flag值为1

int[] flag[n];
while(i < n){
	flag[i] = 0;
}//数组初始化都为0

do{
	while(flag[j] == 1);//flag[j] = 1,临界区中有进程j
	//当flag[j] = 0的时候,说明进程j退出临界区.当前进程可以进入
	flag[i] = 1;//修改当前临界区使用状态
	critical section
	flag[i] = 0;//退出修改临界区状态
	remainder section
}while(1)
```

#### 皮特森算法
* 皮特森算法是对上两个算法的综合,即标志和标志数组同时使用.

```
int  turn; // 该谁进入临界区
bollean flag[];  //进程是否准备好进入临界区
PETERSON算法
do{
	flag[i] = TURE;//进程i准备好进入临界区
	turn=j;//但是临界区的下一个访问是j
	while(flag[j]&&turn==j);//flag[j] = true && turn = j,说明j在临界区
 	CRITICAL SECTION //当j退出临界区,进程i可以进入执行
	flag[i]=FLASE;//进程i执行完毕,修改状态
   REMAINDER SECTION//提醒其他线程
} while(TURE);
```

* 上面是两个线程互斥的实现,对于n个线程需要一个线程等待队列来完成实现.

![皮特森n个进程算法](https://github.com/zzhangyuhang/operating-system/blob/master/photo/8.皮特森n个进程算法.png)

如图,线面为保存等待进程的队列,当进程i之前的先进入了i才能进入,i之后的必须等待i先进入了才能进入.REMAINDER SECTION,提醒的时候提醒队列中的下一个线程,并修改 turn等于该进程号.

### 基于硬件原子操作的高层抽象实现
* 硬件提供了一些源语,用原子操作直接实现进退临界区.
* 锁是一个抽象的数据结构
	* Lock: Acquire() - 锁被释放前一直等待,直到获得锁
	* Lock: Release() - 释放锁,唤醒任何等待的进程
	* 使用锁来控制临界区很容易实现.
* 互斥可以使用锁来实现
* 通常需要一定等级的硬件支持
* 大多数现在体系结构都提供的原子操作指令.
	* Test-and-Set 
		* 从内存中读值
		* 测试该值是否为预期值
		* 是预期值则执行更改操作,否则不执行
	* exchange
		* 交换内存中的两个值

#### 锁的设计

![锁的设计](https://github.com/zzhangyuhang/operating-system/blob/master/photo/8.锁的设计.png)

退出时,改变value = 0 即可.

```
	lock::release(){
		value=0;
	} 
```

我们发现,我们在获取锁的时候,如果当前value = 1,也就是锁被别的进程占用着,当前进程必须要忙等待,等待锁被释放.在忙等待的时候十分的消耗CPU.如何进程改进的呢?

```
class lock{ 
	int value = 0; 
	waitqueue q;//等待队列
}
lock::acquire(){
	while (test-and-set(value)){
		//放入阻塞队列
		add this TCB to wait queen q;
		schedule();
	}
}
lock::release(){
	value=0;//修改锁值
	//唤醒下一个线程t
	remove one thread t from q;
	wakeup(t);
}
```

在获取锁的时候,如果当前锁被占用了,当前线程加入等待队列,然后被阻塞,释放CPU等待前一个线程出临界区的时候释放锁并唤醒它进入临界区继续执行.

但是并不意味着所有的等待都要阻塞,需要考虑临界区的长短问题.如果临界区很长,阻塞线程造成的上下文切换开销小于忙等消耗的CPU性能则需要阻塞进程.如果临界区很短,忙等消耗的CPU性能小于阻塞的上下文切换开销应该采用忙等.

![互斥的实现](https://github.com/zzhangyuhang/operating-system/blob/master/photo/8.互斥的实现.png)
