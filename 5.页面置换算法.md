# 页面置换算法
## 功能和目标
* 功能:当缺页中断发生时,需要调入新的页面,但是内存已经满了,需要选择哪个物理页面置换
* 目标:尽可能减少缺页中断(页面换入换出)次数,即缺页中断次数,因为页面换入换出设计的是磁盘的读写,比内存读写要慢一个级别.具体来说,把未来不再使用的或短期内较少使用的页面换出,通常只能在局部性原理指导下依据过去的统计数据来进行预测.
* 页面锁定(frame locking)
	* 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用程序.
	* 实现的方法是:在页表中添加锁定标志位(lock bit)
* 对进程访问页轨迹的简化

对页(虚拟地址)访问一般是给出(页号,偏移量)来进行访问的.然后我们这里只关心页号,因为页面置换算法的基本单位是页.然后对页号轨迹再次用代号进行简化.

![页的访问轨迹](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.页的访问轨迹.png)

* 实验方法
	* 模拟一个界面置换的行为并且记录产生页缺失数的量.
	* 改进算法,减少更少的缺失,获取更好的性能.

## 最优页面置换算法(OPT)
### 基本思路
* 当一个缺页中断发生时,对于保存在内存当中的每一个逻辑页面,计算在它的下一次访问之前,还需要等待多长时间,从中选择等待时间最长的那个,作为被置换的页面.
* 这是一个理想的情况,在实际操作系统是无法实现的.因为操作系统并不知道未来每个页面的访问情况,以及每一个页面要等待多长时间后才会再次被访问.
* 因为算法基于未来页面的访问所以无法实现,一般用于其他置换算法的性能评价.选取一个点的时间,一段时间后,在产生了访问数据后,用最优页面置换算法进行性能评估.

### 算法过程

![最优置换算法1](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.最优置换算法1.png)

如图,最上边Time是时间序列,Requests是对应时刻下的页面访问请求.左边(page-frame)是物理内存中有的页面,Faults表示产生缺页中断,Time page needed next表示下此访问页面的时间间隔.

当我们处理前四个时刻的访问的时候,物理内存中存在对应的页面正常访问.

![最优置换算法2](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.最优置换算法2.png)

当到**5**这个时刻的时候,访问**e**页面,但是内存并没有,产生缺页中断,需要页面替换.我们找出物理内存中的四个页面距离e的最近访问的时间点.(a = 7,b = 6,c = 9,d = 10)

![最优置换算法3](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.最优置换算法3.png)

我们找到在**5**时刻未来这段时间段内最近访问时间的最远的页面**d**,替换成**e**.

![最优置换算法4](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.最优置换算法4.png)

注意,时刻**10**访问**d**的时候会产生一次缺页中断,因为物理内存中并没有响应的页面,所以需要页面置换,但是并没有未来时刻的数据,需要等到有数据之后才可以完成最优置换.

## 先进先出算法(first-in first-out FIFO)
### 基本思路
	
* 选择在内存中驻留时间最长的页面并淘汰.(注意并不是最久未访问的时间,而是加入内存的时间)
* 具体来说,系统维护着一个链表,记录了所有位于内存当中的逻辑页面.从链表的排列顺序来看,链首页面的驻留时间最长,链尾页面的驻留时间最短.当放生一次缺页中断的时候,把链首的页面淘汰出局,把新的页面添加到链表末尾.
* 性能较差,调出的页面可能是常用页面(驻留时间长,本身就说明可能常用),有belady现象.(给的物理页帧越多反而缺页越频繁)
* FIFO belady现象：分配的物理页数增加，缺页率反而提高，原因是FIFO忽视了进程访问的动态特征。多次访问的不要走。尤其是最坏情况发生时，易高缺页率。 
Belady 是个人名.
* 因为缺页率较高,很少单独使用.
### 过程

![FIFO链表](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.FIFO链表.png)

如图所示,FIFO需要用到的驻留时间链表是通过简单链表来时间的,一个单指针就足够了.如果想要更加方便快捷可以再增加一个尾指针.

![FIFO过程](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.FIFO过程.png)

如图,FIFO所维护的驻留时间队列为**a->b->c->d**,从左到右驻留时间依次减少.当到时刻**5**的时候发生缺页中断,根据链表选择驻留时间最久的**a**进行置换,a -> e,然后调整链表,把**a**移除链表,把**e**加入到链表末尾.链表为**b->c->d->e**.依次类推.

我们发现,FIFO算法产生缺页中断次数是相当多的,性能也是比较差的.

## 最近最久未使用算法(least recently used LRU)
### 基本思路
* 选择最久未使用的那个页面淘汰.
* 根据程序局部性原理,在最近一小段时间内,如果某个页面频繁被访问,那么在未来的一段时间内也有可能再一次频繁的被访问.反过来说,如果在过去某些页面长时间未被访问,那么在将来还可能会长时间得不到访问.

### 与最优置换算法的异同
* 相同点:都是选择最久没有使用的页面进行淘汰
* 不同点:最优置换算法基于未来数据/最近最久未使用算法基于历史数据
	* 最优置换算法,使用未来的数据来选择最久没有使用过的页面进行淘汰.但是没有办法实现预知未来,所以需要用已有数据进行计算.在产生了数据的情况下,在产生缺页中断的那个时间点为起点,在后续最近页面访问数据中找出最久没被访问过的页面进行替换.
	* 最近最久未使用算法,使用历史数据来选择最近最久没有使用过的页面进行淘汰.所以是不缺数据的.当某个时刻产生缺页中断,以这个时间点为终点,在之前最近页面访问数据中找出最近最久没有访问过的页面进行替换.

### 过程

![LRU过程](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.LRU过程.png)

如图所示,在时刻**5**的时候产生缺页中断,然后我们从最近的时间段内**1 -> 4**找出最久未使用的页面,**(a:2,b:4,c:1,d:3)**,根据访问时间,最久未使用的页面是**c**,所以用**e**置换页面**c**.依次类推.

在上述过程中发现,需要一个数据结构来维护页面的访问时间,然后根据最久未访问的时间来确定置换的页面.

两种可能的实现方法：
 
* 系统维护一个页面链表，最近刚使用的页面最为首节点，最久未使用的页面作为尾节点，每次访问内存动态更新头结点。每次访问的时候,找到相应的界面,把他从链表中摘下来,添加到链表首.缺页中断时，淘汰末位的页面。
* 活动页面堆栈：访问某页时，将此页号入栈，压入到栈顶,考虑栈中是否有重复页,若有去除栈内的重复页。淘汰栈底的页面.(栈是先进后出，只有栈顶开口，怎么pop栈底？）
* 注意:动态更新（插，删，内部调整）堆栈和链表要开销.

![使用页面栈实现LRU](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.使用页面栈实现LRU.png)

如图,当访问**5**时刻的**e**的时候,把**e**压入栈中,栈底部的**c**是最久未访问的页面淘汰掉.访问**6**的**b**的时候,因为没有产生缺页中断,无需淘汰页面,只把**b**压入栈中,然后去除栈内除顶部的**b**页面,以此类推.

## 时钟页面置换算法(clock)
* 与LRU的近似,对FIFO的改进
### 基本思路
* 需要用到页表项的访问位,当一个页面装入内存时,把该页面的访问位初始化为0.被访问时(读/写),硬件把该位置为1.(0 - 未访问,1 - 最近被访问)
* 把各个页面组成环形表类(类似钟表面),指针指向最老的页面(最先进来的页面).
* 当发生一个缺页中断时,考察指针所指向的最老的页面,该页面的访问位是0则被淘汰,如果是1则将访问位改为0,然后指针向下移动一格继续考察.如此下去直到淘汰某页.然后把指针再向下移动一格.
* clock算法缺页次数较为接近LRU算法.

### 环形页面链表结构
* 和LRU,FIFO同样用于一个数据结构来保存页面的状态来选择淘汰页面.clock算法则是用一个环形链表来实现.
* 通过环形链表找到最老的**used bit = 0**的页面进行替换.

![环形链表结构](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.环形链表结构.png)

上图为环形链表的结构,每个页都有自己的状态位,resident bit位存在位,used bit为访问位,后边是frame number.

根据页面的进入顺序,依次的将其排列成为环形的链表.指针指向最老的页面.图中最老的页面是**page 0**,指针也指向它.当物理内存满时发生缺页中断,需要找到一个页面进行替换.首先查看指针位置的页面**page 0**状态,判断**used bit**.为**1**,不进行替换,而是将**1**置**0**,然后将指针下移动到**page 3**,同理将该页面**used bit**置**0**,然后下移指针到**page 1**,页面**page 1**的**used bit**为**0**,淘汰,被置换.(注意置换进来的页面**used bit**为**1**)最后再将指针下移到**page 7**,完成本次置换.

### 示例

![clock示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.clock示例.png)

图片下半部分为环形链表结构,青色为当前访问指针.表格前边数字为当前**used bit**值.环形链表的页面先后顺序是有进驻内存时间决定的.

当访问到时刻**5**的时候产生缺页中断,需要进行页面置换.然后查看环形链表.从**a**开始**used bit**都为1,则置0下移指针.当指针移动一圈移回**a**的时候,页面**a**的**used bit**为0,淘汰被置换掉,**e**被换进来.依次类推

## 二次机会法(enhanced clock)
* 是对clock算法的改进.
### 基本思路
* 页面被置换出去的时候是区分读写的.当该页面未被修改直接释放掉即可,当该页面被修改过了则需要将修改内容写回磁盘.因为写操作需要再次访问磁盘,所以花费更大的代价.
* 页面标志位也记录了页面是否被修改,dirty bit来记录,为1则被修改过,0则未被修改.被修改过的页面称为"脏页".
* 修改clock算法,使他允许脏页总是在一次时钟头扫描中保留下来,减少写回磁盘的操作.
* clock算法只通过used bit来决定是否进行置换,enhanced clock需要判断是否脏页,所以需要used bit + dirty bit来进行状态判断.
* 状态判断
	* (0,0) -> 上次没被访问过,也没被修改过  -> 替换掉
	* (1,0) -> 上次访问过,但没被修改过  -> 改变状态,这次未访问,未修改 (0,0)
	* (0,1) -> 上次未访问,但被修改过  -> 改变状态,这次未访问,未修改 (0,0)
	* (1,1) -> 上访问过,也修改过 -> 改变状态,这未访问,但修改过 (0,1)

![二次机会法状态转换](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.二次机会法状态转换.png)

我们看到,当页面被修改过都会被修改两次状态后才会被淘汰,所以减低了脏页被置换的次数,提高了置换的性能.也因此得名二次机会法.

### 示例

![二次机会法示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.二次机会法示例.png)

如图,页面小标w指的是写的访问.环形链表初始状态都为**(1,0)**,然后依次访问到时刻**5**.注意,时刻**1-4**的访问虽然没有发生缺页中断,但是需要改变标志位信息.比如**a,b**被写入,修改**dirty bit**.在时刻**5**产生了缺页中断,进行页面置换.指针指向页面**a**,该页的状态是**(1,1)**,修改状态**(0,1)**,然后移动指针到页面**b**,该页的状态位**(1,1)**,修改状态**(0,1)**,再次移动指针到页面**c**,该页状态为**(1,0)**,修改状态**(0,0)**,然后到页面**d**,修改状态**(0,0)**.进行了一圈循环并没有找到能被置换的页面,所以要继续循环.从页面**d**再到**a**,此时页面**a**的状态为**(0,1)**,修改为**(0,0)**,然后下移动指针到页面**b**,修改状态位**(0,0)**,移动指针到页面**c**,该页状态为**(0,0)**,被淘汰,则用页面**e**替换页面**c**,替换完毕后向下移动指针到页面**d**.依次类推.

## 最不常用算法(least frequently used LFU)
### 基本思路
* 当一个缺页中断发生时,选择访问次数最少的那个页面,并淘汰.

### 实现方法
* 对每个页面设置访问计数器,每当一个页面被访问时,该页面的计数加一.产生缺页中断的时候替换访问次数最少的页面.

### 与LRU区别
* LRU考察的是多久未访问,时间越短越值得留在内存中.
* LFU考察的是访问次数,次数越多越值得留在内存中.

### 局限性
* 并不能很好解决缺页中断.
	* 例如一个页面在进程开始时使用很多,但以后就不使用了,此时LFU不适用.
	* 解决办法:需要把访问的时间因素也考虑进去,在一段时间内考察LFU.或者,设立衰减期,定期的把次数寄存器右移一位(次数除二减半).
* 硬盘计数器空间开销大
* 产生缺页中断时顺序查找访问次数最小的页面时间开销大.

## Belady现象
* 在采用FIFO算法时,有时会出现分配的物理页面数增加,缺页率反而提高的异常现象.

### 原因
* FIFO置换算法的特征与进程访问内存的动态特征是矛盾的.与置换算法的目标是不一致的(即替换较少使用的页面).因此,被它置换出去的页面并不一定是进程不会访问的.

### 示例

![三个物理页帧的FIFO](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.三个物理页帧的FIFO.png)

图中最左边白色框个数是页帧个数,物理内存分配了三个物理页帧.最下边X表示产生了缺页中断.当产生缺页中断的时候,淘汰head处的页面,把缺少的页面放到tail处.相当于一个队列,每次都淘汰头部的页面,每次进入的页面都放在尾部.注意,当正常访问的时候(不缺页),链表的顺序是不变的,并不会因为访问时间而调整链表顺序.

增加到四个物业页帧会怎么样呢?

![四个物理页帧的FIFO](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.四个物理页帧的FIFO.png)

如图,同样的页面访问顺序,增加了一个物业页帧,似乎能够减少缺页中断次数,但是反而增加了.这就是FIFO的Belady现象.注意,只有FIFO才会产生这个现象.

下图是LRU增加物理页帧的对比

![LRU增加物理页帧对比](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.LRU增加物理页帧对比.png)

图中可以看到,LRU算法在增加物理页帧后明显缺页中断次数减少了.这是为什么?因为LRU根据页面的访问时间进行了栈内调整,而FIFO则没有,按照进来顺序一直不会变.

## 算法比较

* LRU和FIFO本质上都是先进先出的思路.
	* LRU是针对页面最近访问时间来进行排序,所以要在每一次页面访问的时候动态的调整各个页面之间的选后顺序.
	* FIFO是针对页面进入内存的时间来进行排序,这个时间是固定不变的,所以各个页面之间的先后顺序是固定的.
* 如果一个页面在进入内存后没有被访问,那么它的最近访问时间就是它进入内存的时间.如果页面都未访问过,LRU就退化成为FIFO.所以LRU对程序具有局部性具有严格要求.
* 性能和开销
	* LRU算法性能好,但是需要动态调整,系统开销大.FIFO算法系统开销小,但是可能会发生Belady现象.clock折中.
	* clock在每一次页面访问的时候动态调整页面在链表中的顺序,而是做一个标记,然后等到发生缺页中断的时候,在把它移动到链表末尾.
* 对于内存当中那些未被访问的页面,clock和LRU一样好.而对于那些曾经访问过的页面,它不能向LRU那样记住他们的准确位置.

## 全局置换算法
* OPT,FIFO,LRU,LFU都是局部的页置换算法.
* 程序的运行具有阶段性,是动态变化的过程.开头缺页次数比较多,中间较为稳定,结尾也比较多.
* 内存中同时运行多个程序,如果每个程序都分配相同的物理页帧就失去了灵活性.
* 需要对整个程序进行全局的置换调整.

### 工作集模型

#### 概念
* 工作集（working set）：一个进程当前使用的逻辑页面集合 
* 用一个二元函数W(t,Δ)表示
	* t是当前执行时刻.
	* Δ是工作集窗口(working-set window),一个定长的页面访问的时间窗口.
	* t+Δ构成了一个时间段.
	* W(t,Δ)就是在当前时刻t之前的Δ时间内(不包含t时刻)所有访问页面组成的集合.
	* 集合在随t不断更新。
	* |W(t,Δ)|是工作集的大小即页面数目。

#### 用途
* 工作集模型用来定量分析程序局部性.
	* 前面介绍的各种页面置换算法,都是基于程序的局部性原理.怎么判断程序是否具有局部性呢?如果程序局部性原理不成立,那么各种页面置换算法没有什么区别,也没有什么意义.每次访问都会产生缺页中断.如果局部性原理存在,如何证明存在,如果对其进行定量分析?需要采用工作集模型.

#### 例子

![工作集示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.工作集示例.png)

注意,工作集中不保存重复的页面.

如图,t2的工作集具有良好的程序局部性,而t1则不具有,但是t1中间部分具有良好的局部性.

#### 程序工作集变化

* 进程开始执行后,随着访问新页面逐步建立较稳定的工作集.当内存访问的局限性的位置大致稳定时,工作集的大小也大致稳定;局部性局域的位置改变,工作集快速扩张和收缩过度到下一个稳定值.

![程序工作集变化](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.程序工作集变化.png)

### 常驻集
#### 概念
* 在当前时刻，进程实际驻留在内存当中的页面集合.

#### 与工作集的关系

* 工作集是程序运行中的固有性质,而常驻集取决于系统分配给进程的物理页面数目和所采用的置换算法。
* 如果一个进程的整个工作集都在内存当中,常驻集与工作集基本重叠，则不会造成太多缺页中断。(直到工作集发生剧烈变动过度到另一个状态).
* 当常驻集大小达到某个数目后，再分配物理页帧也不会有明显下降的缺页率——可以把多出来的物理页帧分给其他程序了。

### 工作集缺页置换算法
#### 基本思路
* 追踪之前的（Δ）段时间内的引用,找出工作集。
* 不管是否产生缺页中断,都会将超出工作集窗口的页面从常驻集(物理内存)替换出去.
* 确保始终有空余的物理页帧给其他程序提供内存,使系统缺页率降低.

#### 示例

![工作集缺页置换算法](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.工作集缺页置换算法.png)

如图,本例的工作集窗口大小为4,也就是在该时刻在内向后查找3个时刻的页面.在时刻**0**之前的工作集为**[e,d,a]**(按照进入工作集顺序给出).时刻**1**访问页面**c**,未超出窗口大小直接加入,工作集为**[e,d,a,c]**.时刻**2**访问页面**c**,
在工作集中,此时刻查看工作集**[d,a,c]**(注意工作集并不包含重复元素),页面**e**并不在此时刻的工作集中,从当前物理内存中拿出.时刻**3**,工作集为**[a,c,d]**,物理内存页面不变.时刻**4**,工作集为**[c,d,b]**,拿出超出的页面**a**.依次类推.

我们发现,物理内存中只要保存满足当前窗口大小的工作集即可,并不用考虑是否产生了缺页.因为,当前时刻的页面无论是否产生缺页一定会在当前时刻的工作集中.所以,我们只需要在物理内存中拿走不在当前时刻工作集中的页面即可.

注意,这个工具集的窗口是固定不变的.

#### 局限
* 在程序运行过程中,随着程序的运行阶段不同,需要的物理内存也不相同.如果从开始就给定物理内存大小(工作集窗口)未免有些浪费物理内存资源.

### 缺页率页面置换算法

#### 基本思路
* 常驻集可变.例如:每个进程刚开始运行的时候,先根据程序大小给它分配一定数据的物理页面.然后再进程运行过程中,在动态的调整常驻集的大小.
* 当缺页中断产生频繁的时候,一般说明物理内存大小不够正常使用的页面的保存,所以需要扩大常驻集;在缺页中断不怎么产生的时候,说明物理内存大小足够使用,应该适度的减少常驻集的大小.
* 使用缺页率(PFF,page fault frenquency)来动态调整常驻集的大小.

#### 缺页率
* 缺页率 = 缺页次数/内存访问次数 
* 影响因素
	* 页面置换算法
	* 分配给进程的物理页面数目(越多越小)
	* 页面本身的大小（页面大则会小）
	* 编程方法（局部性好就会小）

* 若缺页率高,分配更多物理页面;若过低,则减少工作集来减少其物理页面。使缺页率保持在一个合理的范围内。各个程序之间保持一个平衡。

#### 实现算法
* 当缺页中断发生的时候,从上次缺页时间起计算记录之间的时间间隔.
* 如果该段时间过大,缺页不频繁,需要减少常驻集大小,则异常该段时间内没有引用的页面.
* 如果改短时间比较小,缺页频繁,需要增加常驻集大小,增加缺失页到常驻集中.

#### 示例

![缺页率页面置换算法](https://github.com/zzhangyuhang/operating-system/blob/master/photo/5.缺页率页置换算法.png)

如图所示,上边的窗口大小并不是指的工作集或者常驻集的窗口大小,而是指定的缺页时间的窗口大小.超出这个大小,被认定为缺页不频繁,需要移除该段时间内没有被引用的页面.没有超出这个大小,被认定为缺页不频繁,仅添加缺失页面.

在运行的时候,并不需要关注常驻集的大小,只需要关注缺页的时间间隔,按照规则在常驻集中替换页面即可.在时刻**1**产生缺页中断,因为刚开始运行,直接添加缺失页面**c**到内存中.在时刻**4**的时候产生一次缺页中断,距离上次缺页中断3个时间单位,大于窗口值**2**,所以需要将该段时间内没有访问过的页面全部在常驻集中剔除,剔除**[c,d,b]**以外的所有页面**[a,e]**.时刻**6**,产生缺页中断,距离上次时间间隔为2个时间单位,并没有超出窗口,所以直接将缺失页面**e**添加到常驻集即可.依次类推.

### 抖动问题
* 如果分配给一个进程的物理页面太小,不能包含整个的工作集.即常驻集 < 工作集,那么进程将会造成很多的缺页中断,需要频繁的在内存和外存之间替换页面,从而使进程的运行速度变的很慢,把这个状态成为"抖动".
* 
