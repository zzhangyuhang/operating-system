# 调度

## 基本概念
### 什么是调度
* 上下文切换:切换CPU的当前任务,从一个进程/线程到另一个,保存当前在PCB/TCB中的执行上下文,读取下一个的上下文.
* CPU调度:从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程.
* 调度程序:挑选进程/线程的内核函数(通过一些调度策略)使得效率最高,满足用户需求.

### 什么时候进行调度
* 内核运行调度程序的条件
	* 进程从运行态切换到等待状态
	* 一个进程被终结了

### 进程分类
* 不可抢占进程,调度必须等待当前CPU运行的事件/进程结束.
* 可以抢占进程
	* 调度程序在中断被响应后执行
	* 当前的进程从运行切换到就绪,或者一个进程从等待切换到就绪
	* 当前运行的进程可以被换出
* 现在多为可以抢占的进程，OS决定在何时打断进程，调度程序在中断被响应后执行，当前进程从运行切换到就绪，或者一个进程从等待切换到就绪，可以被换出。

* 可以抢占的地点分类:内核抢占和用户抢占两类
	* 用户抢占,进程抢占发生在用户空间的抢占.
	* 内核抢占,进程抢占发生在内核空间的抢占.
		* 进程在内核中通过系统调用执行,因为系统调用返回时,返回到发起这个调用的进程继续执行,所以内核中不会切换和抢占.只要进程在系统调用时不存在从运行态到阻塞态的变化,操作系统可以确保系统调用返回正常执行,这样不支持内核抢占.但是在内核处于相对耗时较高的操作中(文件或内存的管理)时,执行相当长的时间,不能切换到用户所期望使用的进程,导致用户体验到缓慢的情况.系统调用返回时不是原来的进程而是另一个优先级更高的进程,就是内核中的抢占.
	* 通过支持用户抢占和内核抢占可以更好的满足用户的使用,以及对CPU的利用.

## 调度原则

![CPU占用率](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.CPU占用率.png)

如图,上面是单个进程CPU的使用率.CPU的使用率是波状的,CPU进行大量运算是高峰,而进行系统调用的时候用不到CPU,所以一直是平稳的低值.如果不支持调度的话,在时刻**8**后的CPU等于浪费掉,如果此时能切换到另一个进程进来使用CPU,可以充分利用CPU.

### 调度算法的评价指标
* CPU使用率:CPU处于忙状态的时间百分比.
* 吞吐量:单位时间内完成的进程数量.
* 周转时间：一个进程从初始化到结束包括（所有等待时间）所花费的时间，周转时间=等待时间+服务时间 
* 等待时间：进程在就绪队列中的总时间，进程从就绪态到运行态的时间. 
* 响应时间：一个请求被提交到第一次响应所花费的总时间.

### 调度算法的目标
* 减少响应时间
* 减少平均响应时间的波动，交互系统中，可预测性比高差异低平均更重要
* 增加吞吐量 
	* 减少开销（操作系统开销，上下文切换） 
	* 系统资源的高效利用（CPU,I/O设备）
* 减少等待时间
* 严格公平性
	* 每个进程都公平得到CPU的支持,比如占用相同CPU的时间或等待时间,但是会增加平均响应时间.

* 这些目标都难以全部做到极致,只能取平衡.

## 基本调度算法
### 先来先服务(FCFS first come first served)
* FIFO队列的规定:如果进程在执行中年阻塞,队列中的下一个会得到CPU.
* 如果前边有正在运行或者进程,后边进程只能等待前边所有进程运行完毕后才能得到CPU.

#### 示例

![FCFS](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.FCFS.png)

上图是FCFS的一个示例,根据认读到达顺序来决定CPU执行的顺序.注意,周转时间 = 运行时间 + 等待时间.P1先到直接运行,周转时间:0 + 12 = 12. P2需要等到P1执行完毕后才能执行,周转时间 12 + 3 = 15,P3同理: (12 + 3) + 3 = 18.如果要调整一下顺序,将运行时间较长的P1后移到短任务P2,P3后,平均周转时间明显降低.

#### 优点
* 简单

#### 缺点
* 平均等待时间波动大,根据任务顺序花费时间少的可能反而排在后边.
* 可能导致CPU和I/O之间的重叠处理.没考虑抢占,CPU密集的进程导致I/O闲置,I/O密集型进程也在等.(CPU密集型的进程指该进程需要占用CPU的时间较长,一般用于进行大量计算.I/O密集型进程则是占用I/O时间较长,一般用于大量的文件读写.I/O和CPU执行是两种运行资源)

### 短任务优先(SPN)
* 按照预测的完成时间来将任务入队.

#### 示例

![短任务优先](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.短任务优先.png)

如图所示,就绪队列中根据任务的执行时间来进行排序,执行时间较短的任务排到最前边优先执行.

#### 抢占
* 短任务优先调度策略是支持抢占的. (SRT shortest Remaining Time 最短剩余时间)
* 可以抢占队头进程,也可以抢占正在运行的进程.
	* 抢占队头进程,只需要跟队头进程运行时间比较,短就插入队头即可.
	* 抢占正在运行的进程,需要跟正在运行的进程剩余运行时间进行比较,短则抢占.
* 也可以不完成抢占,支持不抢占策略.

#### 优点
* 最小的平均等待时间和周转时间.

#### 缺点
* 可能导致长任务饥饿，不能保证公平.
* 短任务可用时的任何长任务的CPU时间都会增加平均等待时间.
* 需要预知未来的进程执行时间.
	* 怎么评估进程的执行时间?
		* 简单解决方法:询问用户,如果用户欺骗杀死进程.
		* 问题所在:如果用户不知道怎么办?

#### 运行时间预测
* 根据执行历史看将来CPU突发的持续时间，递归展开.执行历史是该进程之前被CPU调度执行的该执行段的执行时间.
* 然后根据公式计算预测的下一段进程所需要的执行时间.

![短任务优先预测执行时间](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.短任务优先预测执行时间.png)

预测结果会有一定差距,但是趋势是一致的.

![短任务优先预测执行时间结果](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.短任务优先预测执行时间结果.png)

### 最高响应比优先
* 在SPN调度的基础上改进.
* 不可抢占.
* 关注进程等待了多长时间.
* 防止无限期推迟.
* 根据公式R = (W + S) / S 来计算响应比.
	* W:waiting time等待时间.
	* S:service time执行时间
	* 选择响应比(R)最高的进程优先执行.

#### 优点
* 不可抢占,防止无线期延迟进程饥饿.
* 交互性好,响应性好,在降低了周转时间同时让长任务得到了快速响应.防止长任务饿死.

#### 缺点
* 对抢占性支持不够,同时也要预知进程的执行时间,解决方法同最短任务优先.

### 时间片轮转(Round Robin)
* 用时间片来轮流执行,强调公平.
* 在量子切片/时间切片的离散单元中分配处理器,时间片结束时切换到下一个准备好的进程.

#### 示例

![时间片轮转](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.时间片轮转.png)

如图所示,根据进程个数分配相等大小的时间分片,每个进程占一个时间分片依次被CPU执行,当执行完一轮的时候,再次划分时间片给未执行完的进程.依次类推.注意,如果一个进程很短,执行时间完全达不到单个时间片,那么分配的时间只根据实际运行的时间长短进行进程切换.那些时间片运行完且没执行完的进程强制切换到下一个进程.

![时间片轮转例子](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.时间片轮转例子.png)

如图,每个进程每个时间片分配的单元为**20**,在第一轮轮转的时候,**P2**进程运行完后仅用**8**个时间,然后切换到进程**P3**,且以后执行完的**P2**不再参与轮转.没有执行完的进程下轮时间片轮转继续执行.直到执行完毕为止.等待时间看甘特图很好计算出来.

#### 优点
* 公平,相对稳定

#### 缺点
* 平均等待时间较长.上下文切换的额外开销比较大.需要对时间量子进行合理的选择.

#### 时间分片的选择
* 时间分片的选择太大则等待时间过长会退化成FCFS.
* 时间分片太小反应迅速但吞吐量由于大量的上下文切换开销受影响.
* 选择一个合适的时间分片，经验规则是维持上下文切换开销处于1%以内，现在LINUX是千分之一秒.

### 多级队列(multilevel Feedback Queues)

#### 设计思路
* 就绪队列被分成相对独立的队列.
	* 用于前台的进程分配到交互的队列
	* 用于后台的进程分配到批处理的队列
* 每个队列根据不同的进程性质分配不同的调度策略.
	* 前台交互队列分配时间片轮转调度策略
	* 后台队列分配先来先服务的调度策略
* 调度必须在队列间进行.
	* 固定优先级
		* 前台优先级高
		* 后台优先级比前台优先级低
	* 时间切片分配
		* 每个队列都得到一个确定的比率
		* 前台队列占80%
		* 后台队列占20%
* 一个进程可以在不同队列中移动.
	* N级优先级,优先级调度在所有优先级队列中,每个级别内部采用RR调度策略.
		* 时间分片大小随优先级增加而增加
		* 若当前时间分片中没有完成就给当前任务则降到下一个优先级

![多级队列](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.多级队列.png)

* 一个进程，先是I/O密集型，提到高优先级，然后变为CPU密集型，就随着不断消耗时间量子就下降到低的优先级，保证I/O密集型任务停留在高优先级.
* 等待时间越长，优先级越高，服务时间越长优先级越低. 
* 能动态地根据进程的特征调整队列和调度.