# 调度

## 基本概念
### 什么是调度
* 上下文切换:切换CPU的当前任务,从一个进程/线程到另一个,保存当前在PCB/TCB中的执行上下文,读取下一个的上下文.
* CPU调度:从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程.
* 调度程序:挑选进程/线程的内核函数(通过一些调度策略)使得效率最高,满足用户需求.

### 什么时候进行调度
* 内核运行调度程序的条件
	* 进程从运行态切换到等待状态
	* 一个进程被终结了

### 进程分类
* 不可抢占进程,调度必须等待当前CPU运行的事件/进程结束.
* 可以抢占进程
	* 调度程序在中断被响应后执行
	* 当前的进程从运行切换到就绪,或者一个进程从等待切换到就绪
	* 当前运行的进程可以被换出
* 现在多为可以抢占的进程，OS决定在何时打断进程，调度程序在中断被响应后执行，当前进程从运行切换到就绪，或者一个进程从等待切换到就绪，可以被换出。

* 可以抢占的地点分类:内核抢占和用户抢占两类
	* 用户抢占,进程抢占发生在用户空间的抢占.
	* 内核抢占,进程抢占发生在内核空间的抢占.
		* 进程在内核中通过系统调用执行,因为系统调用返回时,返回到发起这个调用的进程继续执行,所以内核中不会切换和抢占.只要进程在系统调用时不存在从运行态到阻塞态的变化,操作系统可以确保系统调用返回正常执行,这样不支持内核抢占.但是在内核处于相对耗时较高的操作中(文件或内存的管理)时,执行相当长的时间,不能切换到用户所期望使用的进程,导致用户体验到缓慢的情况.系统调用返回时不是原来的进程而是另一个优先级更高的进程,就是内核中的抢占.
	* 通过支持用户抢占和内核抢占可以更好的满足用户的使用,以及对CPU的利用.

## 调度原则

![CPU占用率](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.CPU占用率.png)

如图,上面是单个进程CPU的使用率.CPU的使用率是波状的,CPU进行大量运算是高峰,而进行系统调用的时候用不到CPU,所以一直是平稳的低值.如果不支持调度的话,在时刻**8**后的CPU等于浪费掉,如果此时能切换到另一个进程进来使用CPU,可以充分利用CPU.

### 调度算法的评价指标
* CPU使用率:CPU处于忙状态的时间百分比.
* 吞吐量:单位时间内完成的进程数量.
* 周转时间：一个进程从初始化到结束包括（所有等待时间）所花费的时间，周转时间=等待时间+服务时间 
* 等待时间：进程在就绪队列中的总时间，进程从就绪态到运行态的时间. 
* 响应时间：一个请求被提交到第一次响应所花费的总时间.

### 调度算法的目标
* 减少响应时间
* 减少平均响应时间的波动，交互系统中，可预测性比高差异低平均更重要
* 增加吞吐量 
	* 减少开销（操作系统开销，上下文切换） 
	* 系统资源的高效利用（CPU,I/O设备）
* 减少等待时间
* 严格公平性
	* 每个进程都公平得到CPU的支持,比如占用相同CPU的时间或等待时间,但是会增加平均响应时间.

* 这些目标都难以全部做到极致,只能取平衡.

## 基本调度算法
### 先来先服务(FCFS first come first served)
* FIFO队列的规定:如果进程在执行中年阻塞,队列中的下一个会得到CPU.
* 如果前边有正在运行或者进程,后边进程只能等待前边所有进程运行完毕后才能得到CPU.

#### 示例

![FCFS](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.FCFS.png)

上图是FCFS的一个示例,根据认读到达顺序来决定CPU执行的顺序.注意,周转时间 = 运行时间 + 等待时间.P1先到直接运行,周转时间:0 + 12 = 12. P2需要等到P1执行完毕后才能执行,周转时间 12 + 3 = 15,P3同理: (12 + 3) + 3 = 18.如果要调整一下顺序,将运行时间较长的P1后移到短任务P2,P3后,平均周转时间明显降低.

#### 优点
* 简单

#### 缺点
* 平均等待时间波动大,根据任务顺序花费时间少的可能反而排在后边.
* 可能导致CPU和I/O之间的重叠处理.没考虑抢占,CPU密集的进程导致I/O闲置,I/O密集型进程也在等.(CPU密集型的进程指该进程需要占用CPU的时间较长,一般用于进行大量计算.I/O密集型进程则是占用I/O时间较长,一般用于大量的文件读写.I/O和CPU执行是两种运行资源)

### 短任务优先(SPN)
* 按照预测的完成时间来将任务入队.

#### 示例

![短任务优先](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.短任务优先.png)

如图所示,就绪队列中根据任务的执行时间来进行排序,执行时间较短的任务排到最前边优先执行.

#### 抢占
* 短任务优先调度策略是支持抢占的. (SRT shortest Remaining Time 最短剩余时间)
* 可以抢占队头进程,也可以抢占正在运行的进程.
	* 抢占队头进程,只需要跟队头进程运行时间比较,短就插入队头即可.
	* 抢占正在运行的进程,需要跟正在运行的进程剩余运行时间进行比较,短则抢占.
* 也可以不完成抢占,支持不抢占策略.

#### 优点
* 最小的平均等待时间和周转时间.

#### 缺点
* 可能导致长任务饥饿，不能保证公平.
* 短任务可用时的任何长任务的CPU时间都会增加平均等待时间.
* 需要预知未来的进程执行时间.
	* 怎么评估进程的执行时间?
		* 简单解决方法:询问用户,如果用户欺骗杀死进程.
		* 问题所在:如果用户不知道怎么办?

#### 运行时间预测
* 根据执行历史看将来CPU突发的持续时间，递归展开.执行历史是该进程之前被CPU调度执行的该执行段的执行时间.
* 然后根据公式计算预测的下一段进程所需要的执行时间.

![短任务优先预测执行时间](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.短任务优先预测执行时间.png)

预测结果会有一定差距,但是趋势是一致的.

![短任务优先预测执行时间结果](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.短任务优先预测执行时间结果.png)

### 最高响应比优先
* 在SPN调度的基础上改进.
* 不可抢占.
* 关注进程等待了多长时间.
* 防止无限期推迟.
* 根据公式R = (W + S) / S 来计算响应比.
	* W:waiting time等待时间.
	* S:service time执行时间
	* 选择响应比(R)最高的进程优先执行.

#### 优点
* 不可抢占,防止无线期延迟进程饥饿.
* 交互性好,响应性好,在降低了周转时间同时让长任务得到了快速响应.防止长任务饿死.

#### 缺点
* 对抢占性支持不够,同时也要预知进程的执行时间,解决方法同最短任务优先.

### 时间片轮转(Round Robin)
* 用时间片来轮流执行,强调公平.
* 在量子切片/时间切片的离散单元中分配处理器,时间片结束时切换到下一个准备好的进程.

#### 示例

![时间片轮转](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.时间片轮转.png)

如图所示,根据进程个数分配相等大小的时间分片,每个进程占一个时间分片依次被CPU执行,当执行完一轮的时候,再次划分时间片给未执行完的进程.依次类推.注意,如果一个进程很短,执行时间完全达不到单个时间片,那么分配的时间只根据实际运行的时间长短进行进程切换.那些时间片运行完且没执行完的进程强制切换到下一个进程.

![时间片轮转例子](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.时间片轮转例子.png)

如图,每个进程每个时间片分配的单元为**20**,在第一轮轮转的时候,**P2**进程运行完后仅用**8**个时间,然后切换到进程**P3**,且以后执行完的**P2**不再参与轮转.没有执行完的进程下轮时间片轮转继续执行.直到执行完毕为止.等待时间看甘特图很好计算出来.

#### 优点
* 公平,相对稳定

#### 缺点
* 平均等待时间较长.上下文切换的额外开销比较大.需要对时间量子进行合理的选择.

#### 时间分片的选择
* 时间分片的选择太大则等待时间过长会退化成FCFS.
* 时间分片太小反应迅速但吞吐量由于大量的上下文切换开销受影响.
* 选择一个合适的时间分片，经验规则是维持上下文切换开销处于1%以内，现在LINUX是千分之一秒.

### 多级反馈队列(multilevel Feedback Queues)

#### 设计思路
* 就绪队列被分成相对独立的队列.
	* 用于前台的进程分配到交互的队列
	* 用于后台的进程分配到批处理的队列
* 每个队列根据不同的进程性质分配不同的调度策略.
	* 前台交互队列分配时间片轮转调度策略
	* 后台队列分配先来先服务的调度策略
* 调度必须在队列间进行.
	* 固定优先级
		* 前台优先级高
		* 后台优先级比前台优先级低
	* 时间切片分配
		* 每个队列都得到一个确定的比率
		* 前台队列占80%
		* 后台队列占20%
* 一个进程可以在不同队列中移动.
	* N级优先级,优先级调度在所有优先级队列中,每个级别内部采用RR调度策略.
		* 时间分片大小随优先级增加而增加
		* 若当前时间分片中没有完成就给当前任务则降到下一个优先级

![多级队列](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.多级队列.png)

* 一个进程，先是I/O密集型，提到高优先级.(I/O密集型进程一般需要长时间等待用户发起的I/O请求,等待时间越长,优先级越高.请求一旦到达,能优先于其他进程得到CPU执行)
* CPU密集型，就随着不断消耗时间量子就下降到低的优先级，保证I/O密集型任务停留在高优先级.
* 等待时间越长，优先级越高，服务时间越长优先级越低. 
* 能动态地根据进程的特征调整队列和调度.

### 公平共享调度(Fair share scheduling FSS)
* 像LINUX这种系统支持多用户访问,如果一个用户请求的CPU资源占了系统大部分,其他用户则得不到资源执行任务,为了保证所有用户的正常执行,提出的公平共享调度算法.
* FFS算法内容
	* 一些用户组比其他组更重要，保证不重要的组无法垄断资源
	* 未使用的资源按照每个组所分配的资源的比例来分配
	* 没有达到资源使用率目标的组获得更高的优先级
* 公平共享调度可以在用户级别实现公平共享.

## 实时调度
### 概念
* 实时调度定义:正确性依赖于其时间和功能两方面的一种操作系统调度.
* 例如:调度火车,工厂,需要确保任务在规定时间内完成等等.
* 性能指标:
	* 时间约束的及时性(deadlines)
	* 速度和平均性能相对不重要
* 主要特性
	* 时间约束的可预测性
* 类别
	* 强实时系统:需要在保证时间内完成重要的任务,必须完成,否则有严重后果.
	* 弱实时系统:要求重要的进程的优先级更高,尽量完成,非必须完成.例如:播放视频的帧数标准.

### 工作单元

* 任务(工作单元):一次计算,一次文件读取,一次信息传递等等,都是以任务为基本调度单位的,不能拆分.
* 包含属性:
	* 取得进展所需要的资源
	* 定时参数

![工作单元](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.实时调度.png)

上图为实时调度的一个工作单元的示例,图中标识了定时参数:release time:进程处于就绪态的时间;relative deadline:要求任务完成的间隔时间段，每个任务有个特定的时间，要在特定的时间段内完成.absolute deadline:最终的结束时间,任务必须在之前完成.

### 周期任务
* 任务有规律的重复
* 周期 p = inter - release time (p > 0)
* 执行时间 e = 最大执行时间(p > e > 0)
* 使用频率 U = e / p

![周期任务](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.周期任务.png)

上图为周期任务的示例,周期p为**[0 - 15]**,执行时间e为**蓝色块**.频率为**3**.

### 实时调度算法

* RM(Rate Monotonie)速率单调调度
	* 最佳静态优先级调度.(优先级根据任务长短决定,不会变)
	* 根据周期安排优先级.
	* 越短优先级越高.
* EDF(Earliest Deadline First)最早期限调度
	* 最佳动态优先级调度.(优先级根据任务离deadline长短决定,会变)
	* deadline越早优先级越高.
	* 动态调整优先级.

## 优先级反转
### 基本概念
* 优先级反转:是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。
* 可发生在任何基于优先级的可抢占的调度机制中，当高优先级任务要等待低优先级任务时发生 
* 优先级反转的持续时间取决于其他不相关任务的不可预测的行为.

### 示例

![优先级反转](https://github.com/zzhangyuhang/operating-system/blob/master/photo/7.优先级反转.png)

如图所示,Tn表示的是进程,tn表示的是时刻.优先级T1>T2>T3.T3先执行，到t2时访问共享资源，t3时T1抢占，开始执行T1，执行过程中需要访问已经被T3占用的共享资源，但T3还没有释放，所以不能继续执行,T1开始等待.一直到t5时,共享资源被T2抢占执行，此时T1受制于T2的执行时间，导致T1的时间延长了.

### 解决办法
#### 优先级继承
* 如果有共享资源，低优先级任务继承等待它所占的资源的最高优先级任务的优先级，当阻塞发生时资源的拥有者的优先级会自动提升，使中间优先级的不能抢占.
* 如果采用优先级继承办法,T3继承了所占资源的最高优先级,在T3访问完毕后不能被T2抢占,防止T2在资源交替过程中抢占,导致T1高优先级的进程一直受阻.

#### 优先级天花板
* 资源的优先级等于所有可以锁定该资源的任务中优先级最高的那个任务的优先级。事先统计。一旦某任务占用该资源，则优先级提升为资源的优先级。不论阻塞是否发生。 除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务在尝试执行临界区的时候都会被阻塞。 
* 如果采用优先级天花板办法,T3继承了锁定该资源的任务中优先级最高的那个任务的优先级即T1的优先级,在T3访问完毕后不能被T2抢占,防止T2在资源交替过程中抢占,导致T1高优先级的进程一直受阻.




