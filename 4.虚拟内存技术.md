# 虚拟内存技术
## 虚拟内存
### 为什么需要虚拟内存

* 程序规模增长嘟嘟远远大于存储器容量的增长速度.
* 程序越来越大,内存容量不够用.
* 用容量更大的硬盘来帮助内存运行程序,将一些不常用的数据放在硬盘中,常用的放在内存中.
* 操作系统实现虚拟内存,不用程序员操作.

### 克服内存不够的方法
* 程序太大,超过内存容量,可以采用手动的覆盖(overlay)技术,只把需要的指令和数据保存在内存中.
* 程序太多,超过了内存容量,可以采用自动的交换(swapping)技术,把暂时不执行的程序送到外存中.
* 想在有限容量内存中以更小的页粒度为单位撞日更多更大的程序,可以采用自动的虚拟存储技术.

## 虚拟内存出现之前的技术
### 覆盖技术
* 目标:在较小的可用内存中运行较大的程序,常用于多道程序系统,与分区存储管理配合使用.
* 原理:把程序按照自身逻辑结构,换分为若干个功能上相对独立的程序模块.把不同同时执行的模块共享同一块内存区域,按时间先后来运行.
	* 必要部分(常用功能)的代买和数据常驻内存.
	* 可选部分(不常用功能)在其他程序模块中实现,平时放在外存,在需要用到时才装入内存.
	* 不存在调用关系的模块不必同时装入到内存,从而可以相互覆盖,即这些模块公用一个分区.
* 例子

下面这个程序分为了A-E五个模块。左边的树状图表明了这个程序各个模块之间的调用关系。首先，A需要常驻内存，因为它会调用其他模块。B和C都被A调用，他们之间没有相互调用关系，所以B跟C分在一个区。同理，D、E、F也分在一个区。还有一种分法是A占一个常用分区,B,E,F也不存在调用关系,可以分在一个分区.C,D不存在调用关系分在一个分区.

![覆盖技术](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.覆盖技术.png)

* 覆盖方法不只一种,可以设计一个所需内存跟小的覆盖方法.
* 缺点:程序员需要把一个大的程序划分为若干个小的功能块,并确定各个模块之间的覆盖关系,费时费力,增加了编程的复杂度.覆盖模块从外存装入内存,实际上是以时间延长来换取空间节省.

### 交换技术
* 目标:多道程序在内存中,让正在运行的程序或需要运行的程序获得更多的内存资源.
* 方法:
	* 可将暂时不能运行的程序送到外存,从而获得空闲内存空间.
	* 操作系统把一个进程的整个地址空间的内容保存到外存中(swap out),而将外存中的某个进程的地址空间读入到内存中(swap in).
	* 换入换出内容的大小为整个程序的地址空间.(以程序为单位)

![交换技术](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.交换技术.png)

* 问题
	* 交换时机的确定,何时交换?只当内存空间不够或有不够的危险时换出.
	* 交换区的大小:必须足够大以存放所有用户进程的所有内存映像的拷贝;必须能对这些内存映像进行直接存取.
	* 程序换入时的重定位:换出后再换入的内存地址一定要在原来位置上吗?最好采用动态地址映射的方法.
* 程序换入时的重定位:在执行过程中,之前换出去的空间可能被占用了,此时换入的程序只能放在一个新的地方,如何确保寻址不出问题?在内存管理中,页表机制里,逻辑地址跟物理地址存在一个映射关系.因此,只要维护一个动态地页表,就能通过逻辑地址找到换入后的物理地址,这就是动态地址映射方法.
* 注意,每次交换的都是一个程序,因此交换的粒度为一个程序的大小,是比较大的.

### 覆盖和交换的比较
* 覆盖技术只能发生在那些相互之间没有协调关系的程序模块之间,程序员必须给出程序内的各个模块之间的逻辑覆盖结构.交换技术是以内存中程序大小为单位进行的,它不需要程序模块间的关系.
* 交换技术发生在内存中程序与管理程序或操作系统之间,覆盖技术则发生在运行程序的内部.
* 交换技术的交换粒度是程序为单位,覆盖技术交换的粒度是以程序模块为单位.

## 虚拟内存管理技术
### 虚拟技术的目标
* 虚拟内存技术是为了克服覆盖和交换技术的缺点而发展起来的,即有交换技术的"不需要程序员介入"的优点,也有覆盖技术"内存之间的交换粒度小"的优点.
* 目标:
	* 像覆盖技术那这样,不是把程序的所有内容都放在内存中,因而能够运行比当前的空闲内存空间还要大的程序.但做的更好,由操作系统自动来完成,无需程序员的干涉.
	* 像交换技术那样,能够实现进程在内存与外存之间的交换,因而获得更多的空闲内存空间.但做的更好,只对进程的部分内容在内存和外存之间进行交换.

### 基本概念
* 虚拟内存技术可以在页式或段式内存管理的基础上实现.
* 在装入程序时,不必将其全部装入到内存,而只需将当前需要执行的部分页面或段装入到内存,就可以让程序开始执行.
* 在执行过程中,如果需执行的指令或访问的数据尚未在内存(缺页/缺段),则由处理器通知操作系统将对应的页面/段调入内存,然后继续执行程序.
* 操作系统将内存中暂时不使用的页面/段调出保存在外存上,从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面/段.

### 基本特征
* 大的用户空间:通过把物理内存和外存相结合,提供给用户的虚拟内存空间通常大于实际的物理内存,即实现了这两者的分离.
* 部分交换:与交换技术相比,虚拟存储的调入和调出是对部分虚拟地址空间进行的.
* 不连续性:物理内存分配的不连续,虚拟地址空间使用的不连续.

有了虚拟内存管理技术,如果地址线有32位,那么即使物理内存空间很小,通过磁盘的补充配合,每个应用程序都能使用4G的地址空间(虚拟).物理内存只有256M,但是硬盘容量大于4GB,能完成在内存中运行4GB的程序.


![虚拟内存技术](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.虚拟内存技术.png)

如图,因为操作系统内核是关键进程,所以是常驻内存的.P1,P2,P3,P4是四个程序,但是在物理内存中所占的并不是连续空间,并且并没有全部都在物理内存中,而是少部分当前运行需要的放在内存中,不需要的大部分放在了虚拟内存(磁盘)中.逻辑地址和物理地址的映射是通过MMU来完成的.(注:MMU内部包含页表,TLB等等)

### 关键点

![页式内存管理](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.页式内存管理.png)

上图是页式内存管理.在页式管理中,页表完成逻辑页和物理页帧的映射.如果在某一次查找中,逻辑地址的页号在页表中找不到相应的物理页帧号(标志位invalid:1存在,0不存在),会返回一个中断.在运行程序的时候,指把需要的代码和数据片段导入物理内存.当cpu运行相应的片段会去通过页表在物理内存中查找,找不到,中断,操作系统去在磁盘中加载相应的代码和片段,这样就不用把所有代码和数据同时都导入物理内存中.

虽然这个过程并不需要程序员去干涉了,操作系统就能自动完成.如果频繁的产生缺页中断去加载代码和数据也会产生很大的开销.所以需要程序具有局部性.

### 程序局部性
* 程序局部性原理:指程序在执行过程中的一个较短时期,所执行的指令地址和指令的操作数地址,分别局限于一定区域.
* 程序局部性的表现:
	* 时间局部性:一条指令的一次执行和下次执行,一个数据的一次访问和下次访问都在一个较短的时间内.
	* 空间局部性:当前指令和相邻的几条指令,当前访问的数据和邻近的几个数据都集中在一个较小的区域内.
* 通过程序局部性,对虚拟内存来说,当运行程序一部分代码的时候把这部分的代码和数据加载入内存,在执行的时候基本都能满足,大大减少了缺页中断的次数,提升了性能.

### 编写程序方法对缺页率的影响

![编写程序方法对缺页率的影响例子](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.编写程序方法对缺页率的影响例子.png)

要注意，int型在32位机中占据的空间是4个字节，也就是说，程序提供给这个进程的4k空间，刚刚好能够存放A一行的数据，也就是1024个整数。

按照编写方法1，访问顺序为A[0][0]、A[1][0]、A[2][0]、……、A[1023][0]、A[0][1]、A[1][1]、……，比如当我们从A[0][0]访问下一个数据A[1][0]的时候，因为第一行A[0][0]——A[0][1023]已经在内存中占据了所有分配给这个进程的空间，所以这个数组的其他数据其实还在硬盘中，并不在内存里，所以此时会产生一个缺页中断，操作系统就需要先把第一行保存到硬盘中，再把第二行，也就是A[1][0]所在的行从硬盘中挪到内存。依此类推，解法1发生了1024*1024次缺页中断。

按照编写方法2，因为是逐行访问的，所以对每一行进行赋值时，只有当访问这一行的第一个元素时，操作系统才会产生缺页中断，把A这一行的数据搬到内存中。访问这一行接下来的数据时，并不会产生缺页中断（毕竟这一行已经放在内存里了）。依此类推，共产生1024次中断。

完成同一个任务（对一个二维数组赋值），上面两个方法的开销是截然不同的。

### 虚存技术的实现
#### 基本思路
* 大部分虚拟存储系统都采用虚拟页式存储管理技术,即在页式存储管理的基础上,增加请求调页和页面置换功能.
* 基本思路
	* 当一个用户程序要调入内存运行的时候,不是将盖程序的所有页面都装入内存,而是只装入部分的页面,就可以启动程序运行.
	* 在运行过程中,如果发现要运行的程序或需要访问数据不在内存,则操作系统发出缺页中断请求,操作系统处理这个中断,将外存中相应的页面调入内存中,使得程序能够继续运行.
* 随着程序的执行,占用的内存越来越多,可能内存不够用了.此时需要把不常用的页换出去,放到外存中,把需要使用的页换进来,放到内存中.这就是页面置换功能.这个功能实现的好坏直接决定了虚拟内存管理的效率.

#### 页表项状态位
* 为了实现虚拟内存管理的请求调页和页面置换功能,需要在页表项中增加状态:修改位,驻留位,访问位,保护位,来记录当前页映射的页帧的状态来选择相应的处理过程.

![页表项结构](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.页表项结构.png)

* 驻留位:表示该页放在存放还是在外存.如果该位等于1,表示该页位于内存当中,即该页表项是有效的,可使用;如果该位等于0,表示该页当前还在外存当中,如果访问该页表项,将导致缺页中断.
* 保护位:允许对该页做的访问类型控制.如:只读,可读写,可执行等等.
* 修改位:表示此页在内存中是否被修改过.当系统回收该物理页面时,根据此位来决定是否把他的内容写回外存.
	* 没被修改过,回收时不用把页写回外存(内容一致),直接释放空间
	* 修改过,回收时把页写回到外存中.
* 访问位:如果该页面被访问过(包括读操作或写操作),则设置刺猬.用于页面置换算法.

示例:

![虚存管理例子](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.虚存管理例子.png)

上图是个例子，左半部分表示虚拟内存和物理页帧的映射关系。X表示驻留位为0，也就是这页目前保存在外存中，没有相应的物理页帧跟其对应。其他数据表示与其对应的物理页帧号。

下面我们考虑两个命令：

（1）MOVE REG，0

这个命令的含义是：将逻辑地址0中的数据存读到寄存器中。

0地址在页表中对应的页号是0，偏移量为0。页号0对应的物理页帧号是2，偏移量不变也为0。页面大小为4k,实际上访问的是物理地址8k+0，也就是8192。

（2）MOVE REG，32780

这个命令的含义是：将逻辑地址32780中的数据读到寄存器中。

32780，对应的页号是32780/4k=8，也就是32k到36k的区间，这项的驻留位为0，也就是说，这页的内容其实是存放在外存中的，物理内存中不存在对应的页。此时返回一个缺页中断。然后操作系统去磁盘中加载响应的页.

#### 缺页中断

![缺页中断过程](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.缺页中断过程.png)

#### 后备存储(backing store)/二级存储

一个程序中的大量数据是存放在外存中的,需要的时候才把它们读到内存中.在何处保存未被映射的页呢?

* 交换空间(磁盘或者文件):特殊格式,用于存储未被映射的页面.
	* 页面 -> 二级存储
	* 代码段 -> 二进制文件
	* 程序段 -> 库文件
	* 其他段 -> 交换文件(swap file)

#### 虚拟内存的性能

为了便于理解分页的开销,使用有效存储器访问时间(effective memory access time,EAT)来表示分页的开销.

**ETA=访问时间 * 页表命中率 + page fault处理时间 * page fault机率**

注意:page fault机率为缺页中断机率

访问时间 = 内存访问时间 * (1 - page fault机率)

page fault处理时间 = 外存访问时间 + 外存的存储时间

外存存储时间是dirty page的存储时间,dirty page是在内存中被修改过的页,即需要修改还需要存储.

![ETA例子](https://github.com/zzhangyuhang/operating-system/blob/master/photo/4.ETA例子.png)

ETA = 10(1 - p) + 5000000 * (1 * p + 1 * p * q)

上面的EAT=10(1-p)+5000000p(1+q)，10代表访问一次内存的时间，p表示出现缺页的概率。5000000(ms -> ns)表示访问一次硬盘所用的时间，可以看到，访问一次硬盘所用的时间比访问一次内存多得多。

需要注意的是，为什么要乘以（1+q）呢？q表示"需要换出的页已经被修改过的概率"，也就是说，如果需要换出的页已经被修改，那还需要将它在硬盘中对应的内容进行修改，还需要进行写硬盘操作，换出页被修改的概率为 p*q。

访问一次硬盘所用的时间比访问一次内存多得多，只有当p足够小的时候，才能使虚拟内存的平均访问时间接近物理内存。恰巧的是，大部分程序设计中都会尽量使之具有局部性，因此虚拟内存管理的性能是可以得到保障的！



	 
	 
     
        






