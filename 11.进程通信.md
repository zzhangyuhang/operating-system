# 进程通信

## 概述
* 进程通信(IPC,Inter-Process Communication)是进程进行通信和同步的机制
* 为什么要进程通信?
	* 多个线程之间可能需要通过协作来完成一个大任务的时候,进程之间需要进行协作或者数据交互,因此需要进程通信来完成进程间的交互.
* 进程通信提供的两个基本操作
	* 发送操作 : send(message)
	* 接收操作 : receive(message)
* 进程通信流程
	1. 在是通信进程间建立通信链路
	2. 通过send/receive交换消息
* 数据链路特征
	* 物理(共享内存)
	* 逻辑
* 进程之间是相互独立的(不能随意访问对方使用的地址),但另一方面也要相互协作.

### 直接通信和间接通信

![直接通信和间接通信](https://github.com/zzhangyuhang/operating-system/blob/master/photo/11.直接通信和间接通信.png)

左边为间接通信,进程A,B通过内核完成信息交互,是间接通信.

右边为直接通信,进程A,B之间通过共享内存完成信息交互,并不通过内核,是直接通信.

#### 直接通信
* 进程必须正确的命名对方
	* send(P,message) - 返送信息到进程P
	* receive(Q,message) - 从进程Q接受消息
* 通信链路的属性
	* 自动建立链路(进程间是没有互相访问占用地址的权利的,所以链路要通过内核来完成,内核负责建立起各个进程之间的数据链路)
	* 一条链路恰好对应一对通信进程
	* 每对进程之间只有一个链接存在
	* 链接可以是单向的,但是通常为双向的

#### 间接通信
* 为了实现间接通信，要发送到共享区，发送方和接收方都不关注具体的另一方是谁 
* 定向从消息队列接收消息： 
	* 每个消息队列都有一个唯一的ID 
	* 只有他们共享了一个消息队列，进程才能通信 
* 通信链路的属性 
	* 只有进程共享一个共同的消息队列，才建立链路 
	* 链接可以与许多进程相关联 
	* 每对进程可以共享多个通信链路 
	* 连接可以是单向或者双向 
* 操作
	* 建立一个新的消息队列 
	* 通过消息队列发送和接收消息 
	* 销毁消息队列 
* 原语的定义如下 
	* send(A, message) – 发送消息到队列A 
	* receive(A, message) - 从队列A接受消息

### 阻塞和非阻塞通信
  
* 阻塞通信：
	* 阻塞发送：发送方在发送消息后进入阻塞等待，直到接受者成功收到。
	* 阻塞接收：接收者在请求接收消息后进入等待，直到成功收到一个消息。 
* 非阻塞通信：
	* 非阻塞发送：发送方在消息发送后，可立即进行其他操作。
	* 非阻塞接收：没有消息发送时，接收者在请求接收消息后，接收不到任何消息。

### 通信链路层的缓冲
* 0容量：发送方必须等待接收方。
* 有限容量：通信链路缓冲队列满时，发送方必须等待。
* 无限容量：发送方不需要等待。
* 注意,无论缓冲多大,信息接收方在没有消息的时候必须要等待消息的到来.

## 进程通信方式
* 进程通讯的常用手段：信号，管道，消息队列，共享内存等.

### 信号(Signal)
* 进程间软件中断通知和处理机制.
	* 例如:SIGKILL,SIGSTOP,SIGCONT等
* 信号的接收处理
	* 捕获(catch):执行进程指定的信号处理函数被调用,一般处理函数由用户自定义.
	* 忽略(ignore):执行操作系统指定的省缺处理.
		* 例如:进程终止,进程挂起.
	* 屏蔽(mask):闭塞信号因此不会传送（可能是暂时的，当处理同样类型的信号)
* 不足
	* 每个信号量只是一个字节的数据,信息量很少,只有一个信号类型.

#### 信号的实现

![信号的实现](https://github.com/zzhangyuhang/operating-system/blob/master/photo/11.信号的实现.png)

如图,信号的实现步骤为

0. 用户编写好信号处理函数.
1. 在内核注册信号处理函数.
2. 内核处理到相应时间的时候发送信号给信号处理函数.
3. 进程收到内核发送的信号执行信号的处理函数.

思考,在执行过程是怎么样的?

当进程在执行过程中,收到了内核发送来的信号量.然后停下工作,去处理信号量.处理完毕信号量后恢复之前的工作.

怎么做到的?

改进程堆栈.操作系统把系统调用返回的堆栈修改到信号处理函数的入口,再把信号处理函数结束后的地址处理成原有进程中断点的入口.

### 管道(pipe)
* 进程间基于内存文件的通信机制
	* 子进程从父进程集成文件描述符
	* 省缺文件描述符
		* 0,stdin
		* 1,stout
		* 2,sederr
* 进程不知道(不关心)另一端
	* 可能从键盘,文件,程序读取输入
	* 可能写入到终端,文件,程序
* UNIX中的 | 就是管道符号

#### 示例

![管道示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/11.管道示例.png)

ls | more : 完成分页显示目录的功能.

注意,管道是父进程给子进程创建的.图中Shell是父进程,ls和more都是从shell中产生的子进程.作为管道的buffer也是有限的,满了会阻塞，如果ls太慢也会sleep.而管道buffer中的数据是没有任何结构的字节流,如果想要有结构的传输,需要在接受端口把字节流解析成对应的结构.

### 消息队列
* 消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制
	* 每个消息(message)是一个字节序列
	* 相同表示的消息组成按先进先出顺序组成一个消息队列(Message Queues)
* 与管道的区别
	* 管道必须有父进程，数据是字节流，没有数据结构。
	* 消息队列可以多个不相干的进程来传递数据，而且message作为一个字节序列存储，message quenues是消息数组。是一个有意义的结构化。

#### 示例

![消息队列示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/11.消息队列示例.png)

注意,消息队列也是一个buffer,所以也受容量限制.

### 共享内存
* 共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通讯机制
* 进程
	* 每个进程都有私有内存地址空间
	* 每个进程的内存地址空间需明确设置共享内存段
* 线程
	* 同一个进程中的线程总是共享相同的内存地址空间
* 优点
	* 快速,没有多余的拷贝
	* 方便数据共享
	* 数据量大
* 不足
	* 需创建共享区域,占用内存
	* 必须用额外的同步机制来协调数据访问,写的时候要上锁.
* 共享内存是直接的进程通讯方式,不用系统调用send/receive.
* 每个进程都有私有地址空间,其中明确地设置了共享内存段.同一块物理内存映射到不同的地址空间(页表)中去.

#### 示例

![共享内存示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/11.共享内存示例.png)