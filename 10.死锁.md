# 死锁
## 概念
* 死锁:一组阻塞的进程(两个或多个),持有一种资源,等待获取另一个进程所占有的资源,导致都无法继续执行.

## 示例

![死锁示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.死锁示例.png)

如图,当发生死锁的时候必须要有进程对资源的释放才能够解决死锁问题.

注意,因为进程的并发执行才会引起死锁.

## 死锁模型
* 持有资源类型R1,R2...RN.
	* CPU
	* MEMORY
	* I/O
* 每个进程使用资源过程
	* 先请求资源 : request/get <- free resource
	* 使用资源 : use/hold <- requested/used resoure
	* 最后释放资源 : release <- free resource
* 可重复使用的资源
	* 在一个时间只能一个进程使用,且不能被删除.OS杀死拥有资源的进程相当于释放资源
	* 进程使用资源后要释放,让其他进程重用
	* 有物理资源（cpu， I/O通道，主和副存储器），也有抽象的资源（设备和数据结构，如文件，数据库和信号量)
	* 如果每个进程拥有一个资源并请求其他资源，可能导致死锁
* 使用资源
	* 创建和销毁
	* I/O缓冲区的中断，信号，消息，信息
	* 如果接收信息阻塞可能会发生死锁
	* 少见的组合事件可能会引起死锁
* 每种资源有很多实例

## 资源分配图
* 用于表述资源的请求和使用
* 资源分配图,包括两组顶点V和一组边E的集合
	* 顶点V
		* P = {P1,P2...PN},所有进程的集合
		* R = {R1,R2...RN},所有资源的类型,每个资源含有1个或多个实例
	* 边E
		* Pi -> Rj : 进程i请求资源j
		* Ri -> Pj : 资源i被进程j使用

![资源分配图1](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图1.png)

如图,是资源分配图.该图不会发生死锁.

![资源分配图2](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图2.png)

上图的资源分配图会发生死锁,因为R2 -> P2 -> R3 -> P3 -> R2产生了环路.仔细分析一波,P1,P2占用了R2的资源,P1请求R1资源,但是R1资源被P2占用,所以P1不能继续执行,只能阻塞到P2释放掉R1资源.P2请求R3资源,而R3资源被P3占用,所以P2只能等待P3执行完毕后释放掉R3资源才能够继续执行.而P3则请求R2资源,R2的资源被P1,P2占用着,不能继续执行,需要等待P1,P2释放资源.但是P1,P2都处于阻塞状态,P3也无法获得资源被阻塞了.造成最后谁都无法执行下去.

思考,有环路一定会死锁吗?

![资源分配图3](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图3.png)

上图资源分配图中有环路,但是不会发生死锁.因为当P2,P4执行完毕后释放资源,P1,P3就有多余可用资源,不会发生死锁.

在分析了上三幅资源分配图我们可以发现

* 如果图中不包含循环 -> 没有死锁
* 如果图中包含循环
	* 如果每个资源类只有一个实例 -> 死锁
	* 如果每个资源类有多个实例 -> 可能死锁(不一定发生死锁)

## 死锁的特征
* 互斥:在一个时间只能有一个进程使用资源
* 持有并等待:进程持有至少一个资源,并等待获取其他进程持有的额外资源
* 无抢占:一个资源只能被进程在完成进程任务后自愿释放
* 循环等待:存在等待进程集合{P1,P2...PN},P0正在等待P1所占用的资源,P1正在等待P2所有占用资源...,PN-1正在等待PN所占用资源,PN正在等待P1所占用资源.

* 注意,上面是死锁发生的时候所表现出来的特征.即死锁具有的特征,但是上面四个条件都满足但是不一定会发生死锁.

## 死锁的处理办法
* 死锁根据针对处理过程不同分为四种办法
	* 死锁预防,破坏死锁发生的四个条件.
	* 死锁避免,资源分配前判断是否发生死锁,若发生则不分配.
	* 死锁检验,检验是否存在死锁.
	* 死锁恢复,在检验出死锁的时候依次杀死死锁进程直到没有死锁.
* 死锁在处理过程中十分消耗资源和影响性能,所以大部分的操作系统忽略这个问题,假装系统中从来没有发生死锁.例如UNIX

### 死锁预防
* 确保系统永远不会进入死锁状态.
* 死锁具有的四个特征,缺一都不可能造成死锁.所以预防要采用某种策略,限制在任何时刻都不满足死锁的必要条件.
	* 互斥:把互斥的共享资源分装成同时访问的资源.
	* 持有并等待:进程请求资源时,要求它不持有任何其他资源.仅允许进程在开始执行时,一次请求所有需要的资源.这种方法进程利用一种资源,其他资源空闲的时候得不到有效利用.资源利用率低.
	* 非抢占:如进程请求不能立即分配的资源,则释放已经占有的资源.只在能够同时获得所有需要资源时,才执行分配操作.
	* 循环等待:对资源排序,要求进程按照顺序请求资源.但是在实际操作系统中资源数量庞大,排序的时候很消耗性能.在嵌入式操作系统中,资源没有几个,很适合.

### 死锁避免
* 利用额外的先验信息,在分配资源时判断是否会出现死锁,只在不会死锁时分配资源.
	* 要求进程声明所需要资源的最大数量.
	* 限定提供与分配的资源数量,确保满足进程的最大需求.
	* 动态检验资源的分配状态,确保不会出现环形等待.
* 当进程请求资源的时候,系统判断分配后是否处于安全状态.
* 当前系统处于安全状态,针对所有已占有进程,存在安全序列<P1,P2,...,PN>是安全的.
	* Pi要求的资源 <= 当前可用资源 + 所有Pj持有资源(j < i)
	* 如果Pi的资源请求不能立即分配,则Pi等待所有Pj(j < i)完成释放掉资源.
	* Pi完成后,Pi+1可得到所需资源,执行并释放所分配的资源

![安全状态和死锁的关系](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.安全状态和死锁的关系.png)

* 上图为安全状态和死锁的关系.
	* 当系统处于安全状态的时候,一定没有死锁.
	* 当系统处于不安全状态的时候,可能会出现死锁.
* 避免死锁就是确保系统不会进入不安全状态.

#### 银行家算法
##### 思路
* 银行家算法是一种避免死锁产生的算法,类比银行借贷分配为策略,判断并保证系统处于安全状态.
	* 客户在第一次申请贷款的时候,需要声明最大的资金量.
	* 在使用完资金的时候,按时归还.
	* 客户贷款数量不超过声明的最大的资金量,银行家尽量满足客户需求.
	* 类比:
		* 银行家 <-> 操作系统
		* 资金 <-> 资源
		* 客户 <-> 申请资源的线程

##### 数据结构
* n = 进程数量,m = 资源类型数量
* Max(总需求量) : n x m 矩阵.
	* 例如 Max[i,j] = k,进程Pi申请到的最多资源Rj的实例个数为k.
* Available(剩余空闲量) : 长度为m的向量.
	* 例如,Available[j] = k,有k个类型Rj的资源实例可用.
* Allcation(已分配量) : n x m 矩阵.
	* 例如,Allocation[i,j] = k,进程Pi当前分配了k个Rj的实例.
* Need(未来需要量) : n x m 矩阵.
	* 例如,Need[i,j] = k,进程Pi未来需要k个Rj的实例.
* Need[i,j] = Max[i,j] - Allcation[i,j]

##### 安全状态判断
1. Work和Finsh分别是长度为m和n的向量初始化.
	* Work = Availble //当前资源剩余空闲量
	* Finish[i] = false for i : 1,2,3,...,n //线程i的是否结束:false未结束,true结束.
2. 寻找进程Pi:  //找出need需要资源量比work剩余资源量小的进程
	* Finish[i] = false
	* Need[i] <= work
	* 没找到满足的进程Pi,转到步骤4
3. Work = Work + Allcation[i],Finish[i] = true //当前线程i资源需求量小于当前资源剩余量,将资源配置给进程i,完成后回收.
	* 转2,寻找下一个能分配需求的进程
4. 如果所有线程满足 Finsh[i] = true,则系统处于安全状态.

##### 具体流程
0. 初始化 Request<sub>i</sub>为进程Pi的资源请求的向量,Request<sub>i</sub>[j]为进程Pi请求资源Rj的实例个数.
1. 如果Request<sub>i</sub> <= Need[i],当前请求的资源量小于声明的剩下未使用资源量,可继续执行.否则拒绝分配资源.
2. 如果Request<sub>i</sub> <= Availble,当前请求的资源量小于剩余空闲量,可继续执行.否则Pi必须等待,因为资源不足以分配.
3. 通过安全状态判断是否分配资源给进程Pi.
	* 更新一个需要安全判断的新的状态
		* Available = Available[i] - Request<sub>i</sub>
		* Allcation[i] = Allcation[i] + Request<sub>i</sub>
		* Need[i] = Need[i] - Request<sub>i</sub>
	* 对新的状态进行安全判断
		* 判断结果为安全,分配资源给进程Pi
		* 判断结果为不安全,拒绝分配资源给Pi

##### 示例

![银行家算法示例1](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.银行家算法示例1.png)

上图为银行家算法的一个示例,我们看到最大需求矩阵C,是我们进程使用前声明的最大资源使用量Max矩阵.已分配资源矩阵A,是系统已经分配给进程的资源量Allcation矩阵.当前请求资源矩阵C-A,为Need矩阵.(这里把Need矩阵当做请求矩阵,因为Need矩阵的值是能请求的最大值,如果用Need矩阵做请求量的状态安全,那么你请求也一定安全).系统的资源向量R为系统的资源总量,当前可用资源向量v为剩余空闲向量Available.

我们看到当前可用资源向量v为(0,1,1),能分配的请求只有P2进程.进程P2所占用的资源为(6,1,2) + (0,0,1),当P2进程执行完毕后,要释放掉P2使用的所有资源(6,1,3).再加上剩余的(0,1,0).所以当P2运行结束后的可用资源量v变成(6,2,3).然后我们找继续找下一个能安全分配的进程.因为当前可用资源量很多,以后三个进程无论顺序都能以安全正确分配运行完.所以这个这个只要先运行P2进程,状态就是安全的.

![银行家算法示例2](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.银行家算法示例2.png)

上图为另一个例子,我们看到当前可用的资源向量v(0,1,1),用Need矩阵进行安全状态判断.无论我们怎么分配,都没有进程能够以安全状态被分配.所以,这个状态是不安全的.

注意,当所有进程都以安全状态分配运行的时候,这个才是安全状态.

不安全状态不一定是死锁,但安全状态一定不会产生死锁.

### 死锁检测

*  允许系统进入死锁状态,系统定期调用死锁检测算法来搜索系统的资源分配图中是否存在死锁.出现死锁时，则用死锁恢复机制进行恢复.

#### 死锁恢复算法
* 死锁检测算法与银行家算法类似,只不过死锁检测里没有最大请求量这个判断.

##### 数据结构
* Available : 长度为m的向量.每种类型可用资源的数量.
* Allocation : 一个 m x n 的矩阵,当前分配给各个进程的每个资源的数量.
	* 例如,Allocation[i,j] = k,表示进程Pi拥有Rj资源k个实例.

##### 算法流程
1. Work 和 Finsh分别是长度为m和n的向量,初始化:
	* Work = Available //work为当前空闲资源量
	* Allocation[i] > 0 && Finish[i] = false //finish的状态为进程是否结束,false为未结束,true为结束.
2. 寻找进程P<sub>i</sub>满足
	* Finish[i] = true
	* Request<sub>i</sub> < work
	
	没有找到则转4.
3. Work = Work + Allocation[i],Finish[i] = true.

	转到2.
4. 如果某个Finish[i] = false,系统处于死锁状态.

* 算法的时间复杂度为O(m x n^2)

##### 示例

![死锁检测示例1](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.死锁检测示例1.png)

上图为A,B,C为三种资源.因为没有剩余的可用资源了(0,0,0),所以首先只能先满足P0和P2进程,因为他们没有请求新的资源,请求资源为(0,0,0).我们先满足P0进程,P0运行结束后,Finish[0] = ture,释放所有已分配的资源(0,1,0) + (0,0,0) = (0,1,0).当前系统可用的资源再加上P0释放的资源(0,0,0) + (0,1,0) = (0,1,0).根据可用资源的大小,我们再次选择请求的进程,经过比较只能满足P2(0,0,0),P2运行完毕后,Finish[2] = true,释放掉所占用资源(3,0,3) + (0,0,0).可用资源为(0,1,0) + (3,0,3) = (3,1,3).再次寻找下一个进程满足他的资源请求.依次类推<P0,P2,P1,P3,P4>为这个运行顺序所有Finish[i] = true,没有死锁.

 ![死锁检测示例2](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.死锁检测示例2.png)
 
 如图,首先先满足P0,剩余可用系统资源(0,0,0)变成(0,1,0).然后再次寻找进程来满足资源请求.发现不能满足任何进程的请求了.所以只有Finish[0] = true,别的全是false.有死锁.

### 死锁恢复
#### 进程终止
* 终止所有的死锁进程
* 一次只终止一个进程直到死锁消除
* 终止进程的顺序应该是
	* 进程的优先级
	* 进程的运行时间以及还需的运行时间
	* 进程占用的资源
	* 进程完成还需要的资源
	* 终止的进程数目
	* 进程是交互还是批处理(批处理优先)

#### 资源抢占
* 选择被抢占进程
	* 最小成本目标
* 进程回退
	* 回退到最近的安全状态,以及重启进程到安全状态
* 可能出现饥饿
	* 同一进程可能处于一直被抢占的角色


 