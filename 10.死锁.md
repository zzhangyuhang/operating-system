# 死锁
## 概念
* 死锁:一组阻塞的进程(两个或多个),持有一种资源,等待获取另一个进程所占有的资源,导致都无法继续执行.

## 示例

![死锁示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.死锁示例.png)

如图,当发生死锁的时候必须要有进程对资源的释放才能够解决死锁问题.

注意,因为进程的并发执行才会引起死锁.

## 死锁模型
* 持有资源类型R1,R2...RN.
	* CPU
	* MEMORY
	* I/O
* 每个进程使用资源过程
	* 先请求资源 : request/get <- free resource
	* 使用资源 : use/hold <- requested/used resoure
	* 最后释放资源 : release <- free resource
* 可重复使用的资源
	* 在一个时间只能一个进程使用,且不能被删除.OS杀死拥有资源的进程相当于释放资源
	* 进程使用资源后要释放,让其他进程重用
	* 有物理资源（cpu， I/O通道，主和副存储器），也有抽象的资源（设备和数据结构，如文件，数据库和信号量)
	* 如果每个进程拥有一个资源并请求其他资源，可能导致死锁
* 使用资源
	* 创建和销毁
	* I/O缓冲区的中断，信号，消息，信息
	* 如果接收信息阻塞可能会发生死锁
	* 少见的组合事件可能会引起死锁
* 每种资源有很多实例

## 资源分配图
* 用于表述资源的请求和使用
* 资源分配图,包括两组顶点V和一组边E的集合
	* 顶点V
		* P = {P1,P2...PN},所有进程的集合
		* R = {R1,R2...RN},所有资源的类型,每个资源含有1个或多个实例
	* 边E
		* Pi -> Rj : 进程i请求资源j
		* Ri -> Pj : 资源i被进程j使用

![资源分配图1](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图1.png)

如图,是资源分配图.该图不会发生死锁.

![资源分配图2](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图2.png)

上图的资源分配图会发生死锁,因为R2 -> P2 -> R3 -> P3 -> R2产生了环路.仔细分析一波,P1,P2占用了R2的资源,P1请求R1资源,但是R1资源被P2占用,所以P1不能继续执行,只能阻塞到P2释放掉R1资源.P2请求R3资源,而R3资源被P3占用,所以P2只能等待P3执行完毕后释放掉R3资源才能够继续执行.而P3则请求R2资源,R2的资源被P1,P2占用着,不能继续执行,需要等待P1,P2释放资源.但是P1,P2都处于阻塞状态,P3也无法获得资源被阻塞了.造成最后谁都无法执行下去.

思考,有环路一定会死锁吗?

![资源分配图3](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图3.png)

上图资源分配图中有环路,但是不会发生死锁.因为当P2,P4执行完毕后释放资源,P1,P3就有多余可用资源,不会发生死锁.

在分析了上三幅资源分配图我们可以发现

* 如果图中不包含循环 -> 没有死锁
* 如果图中包含循环
	* 如果每个资源类只有一个实例 -> 死锁
	* 如果每个资源类有多个实例 -> 可能死锁(不一定发生死锁)

## 死锁的特征
* 互斥:在一个时间只能有一个进程使用资源
* 持有并等待:进程持有至少一个资源,并等待获取其他进程持有的额外资源
* 无抢占:一个资源只能被进程在完成进程任务后自愿释放
* 循环等待:存在等待进程集合{P1,P2...PN},P0正在等待P1所占用的资源,P1正在等待P2所有占用资源...,PN-1正在等待PN所占用资源,PN正在等待P1所占用资源.

* 注意,上面是死锁发生的时候所表现出来的特征.即死锁具有的特征,但是上面四个条件都满足但是不一定会发生死锁.

## 死锁的处理办法

* 运行系统进入死锁状态,然后恢复.
* 忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统.例如UNIX

### 死锁预防
* 确保系统永远不会进入死锁状态.
* 死锁具有的四个特征,缺一都不可能造成死锁.所以预防要采用某种策略,限制在任何时刻都不满足死锁的必要条件.
	* 互斥:把互斥的共享资源分装成同时访问的资源.
	* 持有并等待:进程请求资源时,要求它不持有任何其他资源.仅允许进程在开始执行时,一次请求所有需要的资源.这种方法进程利用一种资源,其他资源空闲的时候得不到有效利用.资源利用率低.
	* 非抢占:如进程请求不能立即分配的资源,则释放已经占有的资源.只在能够同时获得所有需要资源时,才执行分配操作.
	* 循环等待:对资源排序,要求进程按照顺序请求资源.但是在实际操作系统中资源数量庞大,排序的时候很消耗性能.在嵌入式操作系统中,资源没有几个,很适合.

### 死锁避免
* 利用额外的先验信息,在分配资源时判断是否会出现死锁,只在不会死锁时分配资源.
	* 要求进程声明所需要资源的最大数量.
	* 限定提供与分配的资源数量,确保满足进程的最大需求.
	* 动态检验资源的分配状态,确保不会出现环形等待.
* 当进程请求资源的时候,系统判断分配后是否处于安全状态.
* 当前系统处于安全状态,针对所有已占有进程,存在安全序列<P1,P2,...,PN>是安全的.
	* Pi要求的资源 <= 当前可用资源 + 所有Pj持有资源(j < i)
	* 如果Pi的资源请求不能立即分配,则Pi等待所有Pj(j < i)完成释放掉资源.
	* Pi完成后,Pi+1可得到所需资源,执行并释放所分配的资源

![安全状态和死锁的关系](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.安全状态和死锁的关系.png)

* 上图为安全状态和死锁的关系.
	* 当系统处于安全状态的时候,一定没有死锁.
	* 当系统处于不安全状态的时候,可能会出现死锁.
* 避免死锁就是确保系统不会进入不安全状态.




