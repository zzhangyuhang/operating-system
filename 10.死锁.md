# 死锁
## 概念
* 死锁:一组阻塞的进程(两个或多个),持有一种资源,等待获取另一个进程所占有的资源,导致都无法继续执行.

## 示例

![死锁示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.死锁示例.png)

如图,当发生死锁的时候必须要有进程对资源的释放才能够解决死锁问题.

注意,因为进程的并发执行才会引起死锁.

## 死锁模型
* 持有资源类型R1,R2...RN.
	* CPU
	* MEMORY
	* I/O
* 每个进程使用资源过程
	* 先请求资源 : request/get <- free resource
	* 使用资源 : use/hold <- requested/used resoure
	* 最后释放资源 : release <- free resource
* 可重复使用的资源
	* 在一个时间只能一个进程使用,且不能被删除.OS杀死拥有资源的进程相当于释放资源
	* 进程使用资源后要释放,让其他进程重用
	* 有物理资源（cpu， I/O通道，主和副存储器），也有抽象的资源（设备和数据结构，如文件，数据库和信号量)
	* 如果每个进程拥有一个资源并请求其他资源，可能导致死锁
* 使用资源
	* 创建和销毁
	* I/O缓冲区的中断，信号，消息，信息
	* 如果接收信息阻塞可能会发生死锁
	* 少见的组合事件可能会引起死锁
* 每种资源有很多实例

## 资源分配图
* 用于表述资源的请求和使用
* 资源分配图,包括两组顶点V和一组边E的集合
	* 顶点V
		* P = {P1,P2...PN},所有进程的集合
		* R = {R1,R2...RN},所有资源的类型,每个资源含有1个或多个实例
	* 边E
		* Pi -> Rj : 进程i请求资源j
		* Ri -> Pj : 资源i被进程j使用

![资源分配图1](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图1.png)

如图,是资源分配图.该图不会发生死锁.

![资源分配图2](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图2.png)

上图的资源分配图会发生死锁,因为R2 -> P2 -> R3 -> P3 -> R2产生了环路.仔细分析一波,P1,P2占用了R2的资源,P1请求R1资源,但是R1资源被P2占用,所以P1不能继续执行,只能阻塞到P2释放掉R1资源.P2请求R3资源,而R3资源被P3占用,所以P2只能等待P3执行完毕后释放掉R3资源才能够继续执行.而P3则请求R2资源,R2的资源被P1,P2占用着,不能继续执行,需要等待P1,P2释放资源.但是P1,P2都处于阻塞状态,P3也无法获得资源被阻塞了.造成最后谁都无法执行下去.

思考,有环路一定会死锁吗?

![资源分配图3](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图3.png)

上图资源分配图中有环路,但是不会发生死锁.因为当P2,P4执行完毕后释放资源,P1,P3就有多余可用资源,不会发生死锁.

在分析了上三幅资源分配图我们可以发现

* 如果图中不包含循环 -> 没有死锁
* 如果图中包含循环
	* 如果每个资源类只有一个实例 -> 死锁
	* 如果每个资源类有多个实例 -> 可能死锁(不一定发生死锁)

## 死锁的特征
* 互斥:在一个时间只能有一个进程使用资源
* 持有并等待:进程持有至少一个资源,并等待获取其他进程持有的额外资源
* 无抢占:一个资源只能被进程在完成进程任务后自愿释放
* 循环等待:存在等待进程集合{P1,P2...PN},P0正在等待P1所占用的资源,P1正在等待P2所有占用资源...,PN-1正在等待PN所占用资源,PN正在等待P1所占用资源.

* 注意,上面是死锁发生的时候所表现出来的特征.即死锁具有的特征,但是上面四个条件都满足但是不一定会发生死锁.

## 死锁的处理办法
* 确保系统永远不会进入死锁状态.
* 运行系统进入死锁状态,然后恢复.
* 忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统.例如UNIX

* 前两种方法十分消耗操作系统的资源和性能.



