# 死锁
## 概念
* 死锁:一组阻塞的进程(两个或多个),持有一种资源,等待获取另一个进程所占有的资源,导致都无法继续执行.

## 示例

![死锁示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.死锁示例.png)

如图,当发生死锁的时候必须要有进程对资源的释放才能够解决死锁问题.

注意,因为进程的并发执行才会引起死锁.

## 死锁模型
* 持有资源类型R1,R2...RN.
	* CPU
	* MEMORY
	* I/O
* 每个进程使用资源过程
	* 先请求资源 : request/get <- free resource
	* 使用资源 : use/hold <- requested/used resoure
	* 最后释放资源 : release <- free resource
* 可重复使用的资源
	* 在一个时间只能一个进程使用,且不能被删除.OS杀死拥有资源的进程相当于释放资源
	* 进程使用资源后要释放,让其他进程重用
	* 有物理资源（cpu， I/O通道，主和副存储器），也有抽象的资源（设备和数据结构，如文件，数据库和信号量)
	* 如果每个进程拥有一个资源并请求其他资源，可能导致死锁
* 使用资源
	* 创建和销毁
	* I/O缓冲区的中断，信号，消息，信息
	* 如果接收信息阻塞可能会发生死锁
	* 少见的组合事件可能会引起死锁
* 每种资源有很多实例

## 资源分配图
* 用于表述资源的请求和使用
* 资源分配图,包括两组顶点V和一组边E的集合
	* 顶点V
		* P = {P1,P2...PN},所有进程的集合
		* R = {R1,R2...RN},所有资源的类型,每个资源含有1个或多个实例
	* 边E
		* Pi -> Rj : 进程i请求资源j
		* Ri -> Pj : 资源i被进程j使用

![资源分配图1](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图1.png)

如图,是资源分配图.该图不会发生死锁.

![资源分配图2](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图2.png)

上图的资源分配图会发生死锁,因为R2 -> P2 -> R3 -> P3 -> R2产生了环路.仔细分析一波,P1,P2占用了R2的资源,P1请求R1资源,但是R1资源被P2占用,所以P1不能继续执行,只能阻塞到P2释放掉R1资源.P2请求R3资源,而R3资源被P3占用,所以P2只能等待P3执行完毕后释放掉R3资源才能够继续执行.而P3则请求R2资源,R2的资源被P1,P2占用着,不能继续执行,需要等待P1,P2释放资源.但是P1,P2都处于阻塞状态,P3也无法获得资源被阻塞了.造成最后谁都无法执行下去.

思考,有环路一定会死锁吗?

![资源分配图3](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.资源分配图3.png)

上图资源分配图中有环路,但是不会发生死锁.因为当P2,P4执行完毕后释放资源,P1,P3就有多余可用资源,不会发生死锁.

在分析了上三幅资源分配图我们可以发现

* 如果图中不包含循环 -> 没有死锁
* 如果图中包含循环
	* 如果每个资源类只有一个实例 -> 死锁
	* 如果每个资源类有多个实例 -> 可能死锁(不一定发生死锁)

## 死锁的特征
* 互斥:在一个时间只能有一个进程使用资源
* 持有并等待:进程持有至少一个资源,并等待获取其他进程持有的额外资源
* 无抢占:一个资源只能被进程在完成进程任务后自愿释放
* 循环等待:存在等待进程集合{P1,P2...PN},P0正在等待P1所占用的资源,P1正在等待P2所有占用资源...,PN-1正在等待PN所占用资源,PN正在等待P1所占用资源.

* 注意,上面是死锁发生的时候所表现出来的特征.即死锁具有的特征,但是上面四个条件都满足但是不一定会发生死锁.

## 死锁的处理办法

* 忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统.例如UNIX

### 死锁预防
* 确保系统永远不会进入死锁状态.
* 死锁具有的四个特征,缺一都不可能造成死锁.所以预防要采用某种策略,限制在任何时刻都不满足死锁的必要条件.
	* 互斥:把互斥的共享资源分装成同时访问的资源.
	* 持有并等待:进程请求资源时,要求它不持有任何其他资源.仅允许进程在开始执行时,一次请求所有需要的资源.这种方法进程利用一种资源,其他资源空闲的时候得不到有效利用.资源利用率低.
	* 非抢占:如进程请求不能立即分配的资源,则释放已经占有的资源.只在能够同时获得所有需要资源时,才执行分配操作.
	* 循环等待:对资源排序,要求进程按照顺序请求资源.但是在实际操作系统中资源数量庞大,排序的时候很消耗性能.在嵌入式操作系统中,资源没有几个,很适合.

### 死锁避免
* 利用额外的先验信息,在分配资源时判断是否会出现死锁,只在不会死锁时分配资源.
	* 要求进程声明所需要资源的最大数量.
	* 限定提供与分配的资源数量,确保满足进程的最大需求.
	* 动态检验资源的分配状态,确保不会出现环形等待.
* 当进程请求资源的时候,系统判断分配后是否处于安全状态.
* 当前系统处于安全状态,针对所有已占有进程,存在安全序列<P1,P2,...,PN>是安全的.
	* Pi要求的资源 <= 当前可用资源 + 所有Pj持有资源(j < i)
	* 如果Pi的资源请求不能立即分配,则Pi等待所有Pj(j < i)完成释放掉资源.
	* Pi完成后,Pi+1可得到所需资源,执行并释放所分配的资源

![安全状态和死锁的关系](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.安全状态和死锁的关系.png)

* 上图为安全状态和死锁的关系.
	* 当系统处于安全状态的时候,一定没有死锁.
	* 当系统处于不安全状态的时候,可能会出现死锁.
* 避免死锁就是确保系统不会进入不安全状态.

#### 银行家算法
##### 思路
* 银行家算法是一种避免死锁产生的算法,类比银行借贷分配为策略,判断并保证系统处于安全状态.
	* 客户在第一次申请贷款的时候,需要声明最大的资金量.
	* 在使用完资金的时候,按时归还.
	* 客户贷款数量不超过声明的最大的资金量,银行家尽量满足客户需求.
	* 类比:
		* 银行家 <-> 操作系统
		* 资金 <-> 资源
		* 客户 <-> 申请资源的线程

##### 数据结构
* n = 进程数量,m = 资源类型数量
* Max(总需求量) : n x m 矩阵.
	* 例如 Max[i,j] = k,进程Pi申请到的最多资源Rj的实例个数为k.
* Available(剩余空闲量) : 长度为m的向量.
	* 例如,Available[j] = k,有k个类型Rj的资源实例可用.
* Allcation(已分配量) : n x m 矩阵.
	* 例如,Allocation[i,j] = k,进程Pi当前分配了k个Rj的实例.
* Need(未来需要量) : n x m 矩阵.
	* 例如,Need[i,j] = k,进程Pi未来需要k个Rj的实例.
* Need[i,j] = Max[i,j] - Allcation[i,j]

##### 安全状态判断
1. Work和Finsh分别是长度为m和n的向量初始化.
	* Work = Availble //当前资源剩余空闲量
	* Finsh[i] = false for i : 1,2,3,...,n //线程i没结束
2. 寻找进程Pi:  //找出need需要资源量比work剩余资源量小的进程
	* Finsh[i] = false
	* Need[i] <= work
	* 没找到满足的进程Pi,转到步骤4
3. Work = Work + Allcation[i],Finsh[i] = true //当前线程i资源需求量小于当前资源剩余量,将资源配置给进程i,完成后回收.
	* 转2,寻找下一个能分配需求的进程
4. 如果所有线程满足 Finsh[i] = true,则系统处于安全状态.

##### 具体流程
0. 初始化 Request<sub>i</sub>为进程Pi的资源请求的向量,Request<sub>i</sub>[j]为进程Pi请求资源Rj的实例个数.
1. 如果Request<sub>i</sub> <= Need[i],当前请求的资源量小于声明的剩下未使用资源量,可继续执行.否则拒绝分配资源.
2. 如果Request<sub>i</sub> <= Availble,当前请求的资源量小于剩余空闲量,可继续执行.否则Pi必须等待,因为资源不足以分配.
3. 通过安全状态判断是否分配资源给进程Pi.
	* 更新一个需要安全判断的新的状态
		* Available = Available[i] - Request<sub>i</sub>
		* Allcation[i] = Allcation[i] + Request<sub>i</sub>
		* Need[i] = Need[i] - Request<sub>i</sub>
	* 对新的状态进行安全判断
		* 判断结果为安全,分配资源给进程Pi
		* 判断结果为不安全,拒绝分配资源给Pi

##### 示例

![银行家算法示例1](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.银行家算法示例1.png)

上图为银行家算法的一个示例,我们看到最大需求矩阵C,是我们进程使用前声明的最大资源使用量Max矩阵.已分配资源矩阵A,是系统已经分配给进程的资源量Allcation矩阵.当前请求资源矩阵C-A,为Need矩阵.(这里把Need矩阵当做请求矩阵,因为Need矩阵的值是能请求的最大值,如果用Need矩阵做请求量的状态安全,那么你请求也一定安全).系统的资源向量R为系统的资源总量,当前可用资源向量v为剩余空闲向量Available.

我们看到当前可用资源向量v为(0,1,1),能分配的请求只有P2进程.进程P2所占用的资源为(6,1,2) + (0,0,1),当P2进程执行完毕后,要释放掉P2使用的所有资源(6,1,3).再加上剩余的(0,1,0).所以当P2运行结束后的可用资源量v变成(6,2,3).然后我们找继续找下一个能安全分配的进程.因为当前可用资源量很多,以后三个进程无论顺序都能以安全正确分配运行完.所以这个这个只要先运行P2进程,状态就是安全的.

![银行家算法示例2](https://github.com/zzhangyuhang/operating-system/blob/master/photo/10.银行家算法示例2.png)

上图为另一个例子,我们看到当前可用的资源向量v(0,1,1),用Need矩阵进行安全状态判断.无论我们怎么分配,都没有进程能够以安全状态被分配.所以,这个状态是不安全的.

注意,当所有进程都以安全状态分配运行的时候,这个才是安全状态.

不安全状态不一定是死锁,但安全状态一定不会产生死锁.

### 死锁检测





### 死锁恢复

#### 进程终止
* 终止所有的死锁进程
* 一次只终止一个进程直到死锁消除
* 终止进程的顺序应该是
	* 进程的优先级
	* 进程的运行时间以及还需的运行时间
	* 进程占用的资源
	* 进程完成还需要的资源
	* 终止的进程数目
	* 进程是交互还是批处理(批处理优先)

#### 资源抢占
* 选择被抢占进程
	* 最小成本目标
* 进程回退
	* 回退到最近的安全状态,以及重启进程到安全状态
* 可能出现饥饿
	* 同一进程可能处于一直被抢占的角色


 