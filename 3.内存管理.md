#内存管理
===================================

##计算机体系结构
===================================
![计算机体系机构](https://github.com/zzhangyuhang/operating-system/blob/master/photo/3.计算机体系结构.png)

* CPU：对程序的执行的控制
* 内存：放置程序的代码和数据
* 外设：键盘、鼠标、显示器等，完成各种功能

##内存的层次结构
===================================
![内存的层次结构](https://github.com/zzhangyuhang/operating-system/blob/master/photo/3.内存的层次结构.png)

* 从上到下:处理器(包括cpu寄存器和一二级缓存),主存,磁盘
* 从上到下,容量逐步增大,速度逐步变慢.
* 处理器:CPU直接访问，操作系统不能对其进行直接管理，但速度很快，容量很少
* 主存(物理内存):放置操作系统本身和运行的代码和数据.容量比cache和寄存器大，速度慢些.
* 磁盘:内存有时候不够大，需要把一些数据放在磁盘里（虚拟内存），并且把一些需要永久保存的数据（断电后也能保存下来）放在磁盘里.

##内存管理的目标
================================
* 抽象

希望应用程序在运行中不需要考虑一些物理细节，只需访问一个连续的地址空间，我们称之为逻辑地址空间。

* 保护

多个应用程序可能会因为某些原因去访问其他进程的空间，会破坏其他进程的空间。因此需要一个有效的机制去对他们的各自空间进行隔离、保护。

* 共享

进程之间可能需要交互，通过提供共享空间，让进程之间可以安全、可靠、有效地进行数据的传递。

* 虚拟化

当内存不够的时候，为了让应用程序有足够空间运行，把最需要放在内存的数据放在内存中，暂时不需要的数据可以临时放在硬盘上，通过这个方法可以实现一个大的内存，这个过程对应用程序是透明的，程序看到的都是逻辑地址空间。

* 内存管理需要的技术
	* 程序重定位
	* 分页
	* 分段
	* 虚拟内存
	* 按需分页虚拟内存

##虚拟内存
==================================

![虚拟内存](https://github.com/zzhangyuhang/operating-system/blob/master/photo/3.虚拟内存.png)

如上图:

主存的容量不能完全都能容下这四个程序.
所以执行的时候,我们把优先级最低的p4放到磁盘中

MMU:内存管理单元,硬件组件负责处理cpu的内存访问请求

##地址空间
=================================
* 物理地址空间

和硬件直接对应，如内存条所代表的主存，和硬盘。物理空间的管理由硬件完成。

* 逻辑地址空间

一个运行的程序能看到的地址空间，是个一维的线性的地址空间。

* 物理地址空间和逻辑地址空间的对应

![物理地址空间和逻辑地址空间的对应](https://github.com/zzhangyuhang/operating-system/blob/master/photo/3.物理地址空间和逻辑地址空间的对应.png)

把物理内存抽象成一个一维的地址空间,方便用户访问.

可以理解为逻辑地址空间是对物理地址空间的映射.任何地址空间最终都是落实到物理地址空间.

###地址空间的生成
---------------------------------------------

![地址空间的生成](https://github.com/zzhangyuhang/operating-system/blob/master/photo/3.地址空间的生成.png)

以C代码程序为例：

首先，将代码编译，成为汇编程序。在C代码中，程序，变量的地址其实就是逻辑地址。

汇编语言很多变量还是通过变量名来表示的。通过汇编器转化为机器语言（.o文件），机器语言中，起始地址都是从0开始，并且变量名和函数名都被转化为地址。

Linker将多个.o程序链接为单个可执行的程序（.exe），存放在硬盘中。这个程序的地址已经是全局的分布了，不同的.o程序中变量的地址都已经在单一的程序中有相应的定义。

Loader将硬盘中的可执行程序放在内存中的相应位置，此时将逻辑地址进行相应的分配，使得应用程序在内存中可以正常运行。程序在内存中存在一个偏移量，可以通过偏移量和逻辑地址，可以对程序进行正确的访问和指令的操作。

上面那些转化过程基本不需要操作系统的介入，只需编译器、linker、loader的配合即可完成。

###地址空间映射流程
--------------------------------------------

![地址空间映射流程](https://github.com/zzhangyuhang/operating-system/blob/master/photo/3.地址空间映射流程.png)

CPU中有个MMU，MMU完成从逻辑地址到物理地址的映射（上图中蓝色块）。

流程：

（1）当CPU要执行指令时，ALU向MMU发出请求，带有逻辑地址；

（2）MMU查找逻辑地址的映射表中是否存在对应的物理地址。如果没有，在内存中找

如果找到了，CPU的控制器对主存发出请求。

（3）主存把内容通过指令传给CPU，CPU拿到指令的内容后开始执行。

操作系统在这期间的角色是，在执行指令之前，要把映射表建立好。

###地址安全检查
-------------------------------------

每个程序都有自己的内存使用范围,在使用内存之前需要对范围进行检查,当使用超出范围会出内存异常的错误.

##连续内存分配
==================================

###内存碎片
---------------------------------
* 内存碎片:空闲的不能被使用的内存
* 外部碎片:在分配单元间未使用的内存
* 内部碎片:在分配单元中未使用的内存

###分许连续内存空间
---------------------------------
* 三个简单的分配策略
	* 首次适配:对空闲块列表按照地址进行排序,寻找第一个合适的分区. 
		* 在重分配过程中检查是够有空闲分区能够和相邻的空闲分区合并成更大的空闲块.
		* 优点:简单,易于产生更大的空闲块
		* 劣势:存在外部碎片,并且容易不停加剧.
	* 最优适配:对空闲快列表按照大小排序,寻找一个合适的分区.
		* 重分配的时候需要搜索和合并相邻的空闲分区。
		* 优点:当大部分分配是小尺寸的时候非常有效
		* 劣势:同样无法克服外部碎片。重分配慢（因为空闲块列表是按照大小排列，而不是按照地址排列）。容易产生很多没用的微小碎片。
	* 最差适配:对空闲列表按照大小排序,寻找合适的最大的分区.
		* 重分配需要合并相邻的空间分区。
		* 优点:分配中等尺寸的效果最好.
		* 劣势:重分配慢,外部碎片易于破碎，以致大分区无法被分配.
		
###碎片整理
------------------------------------
* 压缩式碎片整理
	
![压缩式碎片整理](https://github.com/zzhangyuhang/operating-system/blob/master/photo/3.压缩式碎片整理.png)
	
将在不同区域的碎片,整理到一起.
	
将程序的归并在一次.要求程序是可以动态重置的,通过拷贝来完成地址重定位.

需要在程序空闲阶段来完成拷贝,开销大,容易产生错误.

* 交换式碎片整理

如果压缩碎片后依旧放不下新到来的程序怎么办?

把主存中的一些暂时用不到的程序交换到磁盘中,为新到来的程序腾出内存空间.

如果交换的程序较大,时间开销很大.
	

