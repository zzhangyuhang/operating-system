# 进程间的同步
* 同步是多线程共享公共数据的协调执行.
* 同步包括:互斥和条件同步.
	* 互斥:临界区的只能同时又一个进程访问.
	* 条件同步:临界区可以让多个进程同时访问.

## 信号量(semaphore)
* 一个整型int（sem），可进行两个原子操作
	* P() sem–-.如果sem<0，说明没有信号量,需要等待.
	* V() sem++.释放的信号量后,如果sem<=0，说明当前有等着的进程，唤醒挂在信号量上的进程，可以是一个，可以是多个.
	* 注意:当进行PV操作的时候,都先对信号量进行了修改,修改完毕后,通过sem的值来判断接下来的操作.
		* P sem-- -> sem < 0 : 临界区外等待 , sem > 0 : 进入临界区执行
		* v sem++ -> sem <= 0 : 唤醒等待线程 , sem > 0 : 无等待线程,直接离开

* 信号量是整数，有符号，一般初始是大于0的数.一旦小于0就不能继续，要挂在信号量上，其他进程做V操作才能唤醒，具体唤醒哪个取决于具体的算法，如常用FIFO先来先服务，较为公平.若是忙等策略,并不能实现先阻塞先唤醒,只能随机唤醒.
* 信号量是被保护的变量，初始化完成后只能通过P() V()这两个原子操作改变值.
* P操作会阻塞，V不会.

### 简图示例

![信号量示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/9.信号量示例.png)

如图所示,我们用后的两个信号量 sem = 2,相当于两条铁轨.进程相当于火车.我们每进入一辆火车,都要执行P()操作,信号量sem--.前两辆火车进入,能够继续执行.当第三辆火车进入的时候,先执行P()操作,sem--,执行减一后的sem = -1 < 0,说明当前铁轨满了,需要等待错车.当临界区内的火车其中一辆离开了临界区,执行V()操作,sem++,执行加一后的sem = 0 <= 0说明当前有火车等待,需要唤醒等待的火车.至于要唤醒哪个火车具体取决于唤醒的算法,一般用FIFO策略.

### 信号量的实现

#### 结构
* 信号量本身由一个整数值和一个等待队列组成.
	* 整数值定义了信号量的大小.
	* 等待队列用于存储被阻塞的进程.

```
Class Semaphore{
	int sem;
	Waitqueue q;
}
```

#### P操作
* 先对信号量进行减1操作.
* 再判断信号量大小,若小于0说明没有可用信号量需阻塞.

```
Semaphore::P(){
	sem--;
	if(sem < 0){
		q.add(t);
		block(t);
	}
}
```

#### V操作
* 先对信号量进行加1操作.
* 在判断信号量大小,若小于等于0说明当前有阻塞的线程,需要唤醒线程.

```
Semaphore::V(){
	sem++;
	if(sem <= 0){
		q.remove(t);
		wakeup(t);
	}
}
```

注意:在信号量的使用过程中是由硬件支持的禁止中断,在修改信号量的时候是由原子指令来完成的,要么成功,要么失败.

### 信号量的使用
* 信号量的值可以为整数值和二进制值
	* 整数值:n,可以实现临界区共同进入n个进程.同步,
	* 二进制值:0/1,约等于锁.互斥.

#### 二进制信号量实现锁的互斥
* 定义信号量为1,即只能同时有一个进程能获取到信号量.

```
mutex = new Semaphore(1);
mutex->P();//获取信号量
	Critial section;//执行
mutex->V();//释放信号量
```

#### 实现两进程间的调度约束

![两进程间的调度约束](https://github.com/zzhangyuhang/operating-system/blob/master/photo/9.两进程间的调度约束.png)

如图所示,初始化为0的一个信号量(注意不是1).A进程先行,执行了condition->P()操作,sem--,然后判断sem = -1 < 0,则阻塞进程A.B进程后行,在A被阻塞后B执行.当B执行到condition->V()操作的时候,sem++,然后判断sem = 0 <= 0,唤醒阻塞的线程A.这样就实现了A进程先运行,然后阻塞等待B进程运行,B运行完毕唤醒A,A再继续执行.完成了两个进程相互制约.

#### 生产者和消费者问题
##### 约束
* 一个或多个生产者生产将生产的数据放在一个有界的缓冲区里.
* 单个消费者每次从缓冲区取出数据.
* 在任何时间只有一个生产者/消费者可以访问缓冲区.
* 可以有多个生产者写数据,但是写的时候不能有消费者.(互斥)
* 缓冲区为空,消费者必须等待生产者;缓冲区为满,生产者必须等待消费者.(同步约束)

##### 实现
###### 初始化
* 一个用于生产者和消费者互斥的互斥信号量.
* 两个用于反映缓冲区状态的信号量:fullbuffer和emptybuffer.
	* fullbuffer:表示管道可用的数据.每生产一个数据,fullbuffer+1.刚开始缓冲区为0,因为没数据.消费一个数据,fullbuffer-1.
	* emptybuffer:表示管道空闲的空间.每生产一个数据,emptybuffer-1.刚开始可以放满缓冲区,所以为n.消费一个数据,fullbuffer+1.

```
Class BoundedBuffer{
	Mutex = new semaphore(1);//互斥信号量
	fullBuffer = new semaphore(0);//管道可用的数据
	emptyBuffer = new semaphore(n);//管道空闲的位置
}
```

###### 生产
* 每完成一个生产,emptyBuffer-1.fullbuffer+1
* 先使用emptyBuffer.P()操作判断是否有可用空间,若有生产,没有则阻塞生产者.
* 生产完一个数据后,用fullBuffers.V()操作改变可消费数据数量.
* 生产过程中需要进行对消费者的互斥.

```
BoundedBuffer::Deposit(c){//生产
	//先判断是否有空闲位置.
	//先减1,sem < 0,没有可用位置则阻塞生产者.sem > 0 有位置可继续生产.
	emptyBuffer->P();
	
	//生产者生产数据,需要互斥,防止消费者进入
	mutex->P(); 	
		Add c to the buffer; 
	mutex->V();
	
	//生产一个数据完毕,改变反映缓冲区数据的信号量fullBuffer+1
	fullBuffers->V();
}

```

* 注意,这里的两个V操作是可以互换的,因为只有唤醒操作并会对进程进行阻塞.并不会影响结果.但是前边两个P操作是不可以互换的,也就是说必须要先判断是否有空余空间之后再进行互斥消费者.如果先进行互斥消费者,在判断空间不足,该进程被阻塞了.之前互斥了消费者,阻塞后就不会执行到互斥锁释放.这样消费者也不能进入互斥区取数据,而生产者一直阻塞等待消费者取数据,就会造成死锁.

###### 消费
* 每消费一个数据,emptyBuffer+1.fullbuffer-1
* 先使用fullBuffer.P()操作判断是否有可消费数据,若有,消费,没有则阻塞消费者.
* 消费完一个数据后,用emptyBuffer.V()操作改变可用空间数量.
* 消费过程中需要进行对生产者的互斥.

```
BoundedBuffer::Remove(c){ 
fullBuffers->P(); //判断是否有可消费的数据
mutex->P();//互斥生产者
	Remove c from buffer; 
mutex->V();
emptyBuffers->V();//消费完毕后,增加可用空间
}
```

## 管程
### 概念
* 管程是专门管理互斥和条件同步的一个统一进程.
* 目的:分离互斥和条件同步的关注.
* 组成
	* 锁:指定临界区,确保互斥性
	* 条件变量:0个或多个,等待/通知信号量，并发访问共享数据.
* 与信号量区别
	* 信号量面向操作系统的控制同步互斥的语法.
	* 管程是面向编程语言的对信号量的高级实现,是一个管理进程.

### 管程结构

![管程结构](https://github.com/zzhangyuhang/operating-system/blob/master/photo/9.管程结构.png)

如果所示,上面是一个管程的内部结构.

* 每个管程都有一个进入的等待队列(entry queue).只有先获得锁(acquire lock)才能够进入管程锁管理的临界区,如果没有获得锁则进入等待队列.出管程的时候需要释放锁(release lock).在一些语言中自动实现了获得锁和释放锁的过程,例如JAVA的sync.
* 在临界区的共享数据中也有0个或多个条件变量,如图x,y.每个条件变量都有自己的等待队列.如果不满足该条件则在该条件的等待队列中阻塞.
* 管程内有两个操作:wait和signal用于条件变量变化时对进程状态进行操作.
	* wait用于当条件不满足的时候阻塞线程,过程中自动先释放之前获取到的锁,然后睡眠线程,唤醒后自动请求到原本释放的锁.
	* signal用于当条件满足的时候唤醒阻塞线程.

### 管程的实现

```
Class Condition{
	int numWaiting = 0;//等待的进程数
	WaitQueue q;//阻塞队列
}
```

```
Condition::Wait(lock){
	numWait++;
	q.add(Thread);
	release(lock);//释放所占用的锁
	schedule();//选择下一个进程去执行,等于切换
	require(lock);//切换的进行执行完毕本进程请求锁
}
```

```
Condition::Signal(){
	if(numWait > 0){
		q.remove(Thread);
		wakeup(Thread);
		numWait--;
	}
}
```

注意,这里的numWait是等待的线程数,当没有等待的线程就不会对其进行减操作.而信号量里维护的是信号量的数量,在PV操作的时候必须先对其进行加减.

### 管程解决消费者/生产者问题

```
class BoundedBuffer{
	...
	Lock lock;//锁
	int count = 0;//buffer现有容量,最大n
	Condition notFull,notEmpty;//条件变量
	//notFull条件挂在生产者上,满足条件去生产,不满足阻塞
	//notEmpty条件挂在消费者上,满足条件去消费,不满足阻塞
}
```

```
BoundeBuffer::Deposit(c){//生产者
	lock->Acquire();
	//当容量count满了,notFull条件不符合,阻塞生产者
	while(count == n){
		notFull.Wait(&lock);
	}
	Add c to the buffer;
	count++;
	//当有生产了,notEmpty条件不符合,唤醒因此阻塞的消费者
	notEmpty.Signal();
	lock->Release();
}
```

```
BoundeBuffer::Deposit(c){//消费者
	lock->Acquire();
	//当容量count为空,notEmpty条件不符合,阻塞消费者
	while(count == 0){
		notEmpty.Wait(&lock);
	}
	Remove c to the buffer;
	count--;
	//当有消费了,notFull条件不符合,唤醒因此阻塞的生产者
	notFull.Signal();
	lock->Release();
}
```

注意,管程跟信号量的区别.若要使用管程必须要先获取锁,离开释放锁.而信号量不用.

### 管程和临界区的比较

![管程和临界区的比较](https://github.com/zzhangyuhang/operating-system/blob/master/photo/9.管程和临界区的比较.png)

* 同步结构
	* 锁：互斥
	* 条件变量：有条件的同步
	* 其他原语：信号量

* 两个同步互斥的机制，临界区和monitor，比起LOCK都可以解决更广泛的问题，但也都离不开底层的硬件支持。
* 同步互斥的不确定性强，调试困难。
