# 进程间的同步
* 同步是多线程共享公共数据的协调执行.
* 同步包括:互斥和条件同步.
	* 互斥:临界区的只能同时又一个进程访问.
	* 条件同步:临界区可以让多个进程同时访问.

## 信号量(semaphore)
* 一个整型int（sem），可进行两个原子操作
	* P() sem–-.如果sem<0，说明没有信号量,需要等待.
	* V() sem++.释放的信号量后,如果sem<=0，说明当前有等着的进程，唤醒挂在信号量上的进程，可以是一个，可以是多个.
	* 注意:当进行PV操作的时候,都先对信号量进行了修改,修改完毕后,通过sem的值来判断接下来的操作.
		* P sem-- -> sem < 0 : 临界区外等待 , sem > 0 : 进入临界区执行
		* v sem++ -> sem <= 0 : 唤醒等待线程 , sem > 0 : 无等待线程,直接离开

* 信号量是整数，有符号，一般初始是大于0的数.一旦小于0就不能继续，要挂在信号量上，其他进程做V操作才能唤醒，具体唤醒哪个取决于具体的算法，如常用FIFO先来先服务，较为公平
* 信号量是被保护的变量，初始化完成后只能通过P() V()这两个原子操作改变值.
* P操作会阻塞，V不会.

### 示例

![信号量示例](https://github.com/zzhangyuhang/operating-system/blob/master/photo/9.信号量示例.png)

如图所示,我们用后的两个信号量 sem = 2,相当于两条铁轨.进程相当于火车.我们每进入一辆火车,都要执行P()操作,信号量sem--.前两辆火车进入,能够继续执行.当第三辆火车进入的时候,先执行P()操作,sem--,执行减一后的sem = -1 < 0,说明当前铁轨满了,需要等待错车.当临界区内的火车其中一辆离开了临界区,执行V()操作,sem++,执行加一后的sem = 0 <= 0说明当前有火车等待,需要唤醒等待的火车.至于要唤醒哪个火车具体取决于唤醒的算法.


